#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
#elif __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
#endif //__clang__

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DevicesSpec.proto

#ifndef PROTOBUF_INCLUDED_DevicesSpec_2eproto
#define PROTOBUF_INCLUDED_DevicesSpec_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/message.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_DevicesSpec_2eproto

namespace protobuf_DevicesSpec_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable
      serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
} // namespace protobuf_DevicesSpec_2eproto
namespace fc_pb {
class Controller;
class ControllerDefaultTypeInternal;
extern ControllerDefaultTypeInternal _Controller_default_instance_;
class ControllerConfig;
class ControllerConfigDefaultTypeInternal;
extern ControllerConfigDefaultTypeInternal _ControllerConfig_default_instance_;
class ControllerState;
class ControllerStateDefaultTypeInternal;
extern ControllerStateDefaultTypeInternal _ControllerState_default_instance_;
class Devices;
class DevicesDefaultTypeInternal;
extern DevicesDefaultTypeInternal _Devices_default_instance_;
class DevicesRequest;
class DevicesRequestDefaultTypeInternal;
extern DevicesRequestDefaultTypeInternal _DevicesRequest_default_instance_;
class Empty;
class EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class Fan;
class FanDefaultTypeInternal;
extern FanDefaultTypeInternal _Fan_default_instance_;
class Sensor;
class SensorDefaultTypeInternal;
extern SensorDefaultTypeInternal _Sensor_default_instance_;
} // namespace fc_pb
namespace google {
namespace protobuf {
template <>
::fc_pb::Controller *Arena::CreateMaybeMessage<::fc_pb::Controller>(Arena *);
template <>
::fc_pb::ControllerConfig *
Arena::CreateMaybeMessage<::fc_pb::ControllerConfig>(Arena *);
template <>
::fc_pb::ControllerState *
Arena::CreateMaybeMessage<::fc_pb::ControllerState>(Arena *);
template <>
::fc_pb::Devices *Arena::CreateMaybeMessage<::fc_pb::Devices>(Arena *);
template <>
::fc_pb::DevicesRequest *
Arena::CreateMaybeMessage<::fc_pb::DevicesRequest>(Arena *);
template <>::fc_pb::Empty *Arena::CreateMaybeMessage<::fc_pb::Empty>(Arena *);
template <>::fc_pb::Fan *Arena::CreateMaybeMessage<::fc_pb::Fan>(Arena *);
template <>::fc_pb::Sensor *Arena::CreateMaybeMessage<::fc_pb::Sensor>(Arena *);
} // namespace protobuf
} // namespace google
namespace fc_pb {

enum ControllerState_State {
  ControllerState_State_STOP = 0,
  ControllerState_State_RUN = 1,
  ControllerState_State_RESTART = 2,
  ControllerState_State_TEST = 3,
  ControllerState_State_ControllerState_State_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::google::protobuf::kint32min,
  ControllerState_State_ControllerState_State_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::google::protobuf::kint32max
};
bool ControllerState_State_IsValid(int value);
const ControllerState_State ControllerState_State_State_MIN =
    ControllerState_State_STOP;
const ControllerState_State ControllerState_State_State_MAX =
    ControllerState_State_TEST;
const int ControllerState_State_State_ARRAYSIZE =
    ControllerState_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor *ControllerState_State_descriptor();
inline const ::std::string &
ControllerState_State_Name(ControllerState_State value) {
  return ::google::protobuf::internal::NameOfEnum(
      ControllerState_State_descriptor(), value);
}
inline bool ControllerState_State_Parse(const ::std::string &name,
                                        ControllerState_State *value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControllerState_State>(
      ControllerState_State_descriptor(), name, value);
}
enum DevType {
  SYS = 0,
  DELL = 1,
  NVIDIA = 2,
  DevType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DevType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DevType_IsValid(int value);
const DevType DevType_MIN = SYS;
const DevType DevType_MAX = NVIDIA;
const int DevType_ARRAYSIZE = DevType_MAX + 1;

const ::google::protobuf::EnumDescriptor *DevType_descriptor();
inline const ::std::string &DevType_Name(DevType value) {
  return ::google::protobuf::internal::NameOfEnum(DevType_descriptor(), value);
}
inline bool DevType_Parse(const ::std::string &name, DevType *value) {
  return ::google::protobuf::internal::ParseNamedEnum<DevType>(
      DevType_descriptor(), name, value);
}
// ===================================================================

class Controller
    : public ::google::protobuf::
          Message /* @@protoc_insertion_point(class_definition:fc_pb.Controller)
                   */
{
public:
  Controller();
  virtual ~Controller();

  Controller(const Controller &from);

  inline Controller &operator=(const Controller &from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  Controller(Controller &&from) noexcept : Controller() {
    *this = ::std::move(from);
  }

  inline Controller &operator=(Controller &&from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from)
        InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  static const ::google::protobuf::Descriptor *descriptor();
  static const Controller &default_instance();

  static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
  static inline const Controller *internal_default_instance() {
    return reinterpret_cast<const Controller *>(&_Controller_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;

  void Swap(Controller *other);
  friend void swap(Controller &a, Controller &b) { a.Swap(&b); }

  // implements Message ----------------------------------------------

  inline Controller *New() const final {
    return CreateMaybeMessage<Controller>(NULL);
  }

  Controller *New(::google::protobuf::Arena *arena) const final {
    return CreateMaybeMessage<Controller>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message &from) final;
  void MergeFrom(const ::google::protobuf::Message &from) final;
  void CopyFrom(const Controller &from);
  void MergeFrom(const Controller &from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const final;
  ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8 *target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Controller *other);

private:
  inline ::google::protobuf::Arena *GetArenaNoVirtual() const { return NULL; }
  inline void *MaybeArenaPtr() const { return NULL; }

public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .fc_pb.ControllerConfig config = 1;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;

private:
  const ::fc_pb::ControllerConfig &_internal_config() const;

public:
  const ::fc_pb::ControllerConfig &config() const;
  ::fc_pb::ControllerConfig *release_config();
  ::fc_pb::ControllerConfig *mutable_config();
  void set_allocated_config(::fc_pb::ControllerConfig *config);

  // .fc_pb.Devices devices = 2;
  bool has_devices() const;
  void clear_devices();
  static const int kDevicesFieldNumber = 2;

private:
  const ::fc_pb::Devices &_internal_devices() const;

public:
  const ::fc_pb::Devices &devices() const;
  ::fc_pb::Devices *release_devices();
  ::fc_pb::Devices *mutable_devices();
  void set_allocated_devices(::fc_pb::Devices *devices);

  // @@protoc_insertion_point(class_scope:fc_pb.Controller)
private:
  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::fc_pb::ControllerConfig *config_;
  ::fc_pb::Devices *devices_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_DevicesSpec_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ControllerConfig
    : public ::google::protobuf::
          Message /* @@protoc_insertion_point(class_definition:fc_pb.ControllerConfig)
                   */
{
public:
  ControllerConfig();
  virtual ~ControllerConfig();

  ControllerConfig(const ControllerConfig &from);

  inline ControllerConfig &operator=(const ControllerConfig &from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  ControllerConfig(ControllerConfig &&from) noexcept : ControllerConfig() {
    *this = ::std::move(from);
  }

  inline ControllerConfig &operator=(ControllerConfig &&from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from)
        InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  static const ::google::protobuf::Descriptor *descriptor();
  static const ControllerConfig &default_instance();

  static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
  static inline const ControllerConfig *internal_default_instance() {
    return reinterpret_cast<const ControllerConfig *>(
        &_ControllerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;

  void Swap(ControllerConfig *other);
  friend void swap(ControllerConfig &a, ControllerConfig &b) { a.Swap(&b); }

  // implements Message ----------------------------------------------

  inline ControllerConfig *New() const final {
    return CreateMaybeMessage<ControllerConfig>(NULL);
  }

  ControllerConfig *New(::google::protobuf::Arena *arena) const final {
    return CreateMaybeMessage<ControllerConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message &from) final;
  void MergeFrom(const ::google::protobuf::Message &from) final;
  void CopyFrom(const ControllerConfig &from);
  void MergeFrom(const ControllerConfig &from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const final;
  ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8 *target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControllerConfig *other);

private:
  inline ::google::protobuf::Arena *GetArenaNoVirtual() const { return NULL; }
  inline void *MaybeArenaPtr() const { return NULL; }

public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 update_interval = 1;
  void clear_update_interval();
  static const int kUpdateIntervalFieldNumber = 1;
  ::google::protobuf::uint32 update_interval() const;
  void set_update_interval(::google::protobuf::uint32 value);

  // bool dynamic = 2;
  void clear_dynamic();
  static const int kDynamicFieldNumber = 2;
  bool dynamic() const;
  void set_dynamic(bool value);

  // uint32 smoothing_intervals = 3;
  void clear_smoothing_intervals();
  static const int kSmoothingIntervalsFieldNumber = 3;
  ::google::protobuf::uint32 smoothing_intervals() const;
  void set_smoothing_intervals(::google::protobuf::uint32 value);

  // uint32 top_stickiness_intervals = 4;
  void clear_top_stickiness_intervals();
  static const int kTopStickinessIntervalsFieldNumber = 4;
  ::google::protobuf::uint32 top_stickiness_intervals() const;
  void set_top_stickiness_intervals(::google::protobuf::uint32 value);

  // uint32 temp_averaging_intervals = 5;
  void clear_temp_averaging_intervals();
  static const int kTempAveragingIntervalsFieldNumber = 5;
  ::google::protobuf::uint32 temp_averaging_intervals() const;
  void set_temp_averaging_intervals(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fc_pb.ControllerConfig)
private:
  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 update_interval_;
  bool dynamic_;
  ::google::protobuf::uint32 smoothing_intervals_;
  ::google::protobuf::uint32 top_stickiness_intervals_;
  ::google::protobuf::uint32 temp_averaging_intervals_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_DevicesSpec_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Devices
    : public ::google::protobuf::
          Message /* @@protoc_insertion_point(class_definition:fc_pb.Devices)
                   */
{
public:
  Devices();
  virtual ~Devices();

  Devices(const Devices &from);

  inline Devices &operator=(const Devices &from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  Devices(Devices &&from) noexcept : Devices() { *this = ::std::move(from); }

  inline Devices &operator=(Devices &&from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from)
        InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  static const ::google::protobuf::Descriptor *descriptor();
  static const Devices &default_instance();

  static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
  static inline const Devices *internal_default_instance() {
    return reinterpret_cast<const Devices *>(&_Devices_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;

  void Swap(Devices *other);
  friend void swap(Devices &a, Devices &b) { a.Swap(&b); }

  // implements Message ----------------------------------------------

  inline Devices *New() const final {
    return CreateMaybeMessage<Devices>(NULL);
  }

  Devices *New(::google::protobuf::Arena *arena) const final {
    return CreateMaybeMessage<Devices>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message &from) final;
  void MergeFrom(const ::google::protobuf::Message &from) final;
  void CopyFrom(const Devices &from);
  void MergeFrom(const Devices &from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const final;
  ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8 *target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Devices *other);

private:
  inline ::google::protobuf::Arena *GetArenaNoVirtual() const { return NULL; }
  inline void *MaybeArenaPtr() const { return NULL; }

public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fc_pb.Fan fan = 1;
  int fan_size() const;
  void clear_fan();
  static const int kFanFieldNumber = 1;
  ::fc_pb::Fan *mutable_fan(int index);
  ::google::protobuf::RepeatedPtrField<::fc_pb::Fan> *mutable_fan();
  const ::fc_pb::Fan &fan(int index) const;
  ::fc_pb::Fan *add_fan();
  const ::google::protobuf::RepeatedPtrField<::fc_pb::Fan> &fan() const;

  // repeated .fc_pb.Sensor sensor = 2;
  int sensor_size() const;
  void clear_sensor();
  static const int kSensorFieldNumber = 2;
  ::fc_pb::Sensor *mutable_sensor(int index);
  ::google::protobuf::RepeatedPtrField<::fc_pb::Sensor> *mutable_sensor();
  const ::fc_pb::Sensor &sensor(int index) const;
  ::fc_pb::Sensor *add_sensor();
  const ::google::protobuf::RepeatedPtrField<::fc_pb::Sensor> &sensor() const;

  // @@protoc_insertion_point(class_scope:fc_pb.Devices)
private:
  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::fc_pb::Fan> fan_;
  ::google::protobuf::RepeatedPtrField<::fc_pb::Sensor> sensor_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_DevicesSpec_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Fan
    : public ::google::protobuf::
          Message /* @@protoc_insertion_point(class_definition:fc_pb.Fan) */ {
public:
  Fan();
  virtual ~Fan();

  Fan(const Fan &from);

  inline Fan &operator=(const Fan &from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  Fan(Fan &&from) noexcept : Fan() { *this = ::std::move(from); }

  inline Fan &operator=(Fan &&from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from)
        InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  static const ::google::protobuf::Descriptor *descriptor();
  static const Fan &default_instance();

  static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
  static inline const Fan *internal_default_instance() {
    return reinterpret_cast<const Fan *>(&_Fan_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;

  void Swap(Fan *other);
  friend void swap(Fan &a, Fan &b) { a.Swap(&b); }

  // implements Message ----------------------------------------------

  inline Fan *New() const final { return CreateMaybeMessage<Fan>(NULL); }

  Fan *New(::google::protobuf::Arena *arena) const final {
    return CreateMaybeMessage<Fan>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message &from) final;
  void MergeFrom(const ::google::protobuf::Message &from) final;
  void CopyFrom(const Fan &from);
  void MergeFrom(const Fan &from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const final;
  ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8 *target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fan *other);

private:
  inline ::google::protobuf::Arena *GetArenaNoVirtual() const { return NULL; }
  inline void *MaybeArenaPtr() const { return NULL; }

public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string label = 2;
  void clear_label();
  static const int kLabelFieldNumber = 2;
  const ::std::string &label() const;
  void set_label(const ::std::string &value);
#if LANG_CXX11
  void set_label(::std::string &&value);
#endif
  void set_label(const char *value);
  void set_label(const char *value, size_t size);
  ::std::string *mutable_label();
  ::std::string *release_label();
  void set_allocated_label(::std::string *label);

  // string sensor = 3;
  void clear_sensor();
  static const int kSensorFieldNumber = 3;
  const ::std::string &sensor() const;
  void set_sensor(const ::std::string &value);
#if LANG_CXX11
  void set_sensor(::std::string &&value);
#endif
  void set_sensor(const char *value);
  void set_sensor(const char *value, size_t size);
  ::std::string *mutable_sensor();
  ::std::string *release_sensor();
  void set_allocated_sensor(::std::string *sensor);

  // string temp_to_rpm = 4;
  void clear_temp_to_rpm();
  static const int kTempToRpmFieldNumber = 4;
  const ::std::string &temp_to_rpm() const;
  void set_temp_to_rpm(const ::std::string &value);
#if LANG_CXX11
  void set_temp_to_rpm(::std::string &&value);
#endif
  void set_temp_to_rpm(const char *value);
  void set_temp_to_rpm(const char *value, size_t size);
  ::std::string *mutable_temp_to_rpm();
  ::std::string *release_temp_to_rpm();
  void set_allocated_temp_to_rpm(::std::string *temp_to_rpm);

  // string rpm_to_pwm = 5;
  void clear_rpm_to_pwm();
  static const int kRpmToPwmFieldNumber = 5;
  const ::std::string &rpm_to_pwm() const;
  void set_rpm_to_pwm(const ::std::string &value);
#if LANG_CXX11
  void set_rpm_to_pwm(::std::string &&value);
#endif
  void set_rpm_to_pwm(const char *value);
  void set_rpm_to_pwm(const char *value, size_t size);
  ::std::string *mutable_rpm_to_pwm();
  ::std::string *release_rpm_to_pwm();
  void set_allocated_rpm_to_pwm(::std::string *rpm_to_pwm);

  // string pwm_path = 10;
  void clear_pwm_path();
  static const int kPwmPathFieldNumber = 10;
  const ::std::string &pwm_path() const;
  void set_pwm_path(const ::std::string &value);
#if LANG_CXX11
  void set_pwm_path(::std::string &&value);
#endif
  void set_pwm_path(const char *value);
  void set_pwm_path(const char *value, size_t size);
  ::std::string *mutable_pwm_path();
  ::std::string *release_pwm_path();
  void set_allocated_pwm_path(::std::string *pwm_path);

  // string rpm_path = 11;
  void clear_rpm_path();
  static const int kRpmPathFieldNumber = 11;
  const ::std::string &rpm_path() const;
  void set_rpm_path(const ::std::string &value);
#if LANG_CXX11
  void set_rpm_path(::std::string &&value);
#endif
  void set_rpm_path(const char *value);
  void set_rpm_path(const char *value, size_t size);
  ::std::string *mutable_rpm_path();
  ::std::string *release_rpm_path();
  void set_allocated_rpm_path(::std::string *rpm_path);

  // string enable_path = 12;
  void clear_enable_path();
  static const int kEnablePathFieldNumber = 12;
  const ::std::string &enable_path() const;
  void set_enable_path(const ::std::string &value);
#if LANG_CXX11
  void set_enable_path(::std::string &&value);
#endif
  void set_enable_path(const char *value);
  void set_enable_path(const char *value, size_t size);
  ::std::string *mutable_enable_path();
  ::std::string *release_enable_path();
  void set_allocated_enable_path(::std::string *enable_path);

  // .fc_pb.DevType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::fc_pb::DevType type() const;
  void set_type(::fc_pb::DevType value);

  // uint32 start_pwm = 6;
  void clear_start_pwm();
  static const int kStartPwmFieldNumber = 6;
  ::google::protobuf::uint32 start_pwm() const;
  void set_start_pwm(::google::protobuf::uint32 value);

  // uint64 interval = 7;
  void clear_interval();
  static const int kIntervalFieldNumber = 7;
  ::google::protobuf::uint64 interval() const;
  void set_interval(::google::protobuf::uint64 value);

  // bool ignore = 8;
  void clear_ignore();
  static const int kIgnoreFieldNumber = 8;
  bool ignore() const;
  void set_ignore(bool value);

  // int32 driver_flag = 13;
  void clear_driver_flag();
  static const int kDriverFlagFieldNumber = 13;
  ::google::protobuf::int32 driver_flag() const;
  void set_driver_flag(::google::protobuf::int32 value);

  // uint32 id = 20;
  void clear_id();
  static const int kIdFieldNumber = 20;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:fc_pb.Fan)
private:
  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::google::protobuf::internal::ArenaStringPtr sensor_;
  ::google::protobuf::internal::ArenaStringPtr temp_to_rpm_;
  ::google::protobuf::internal::ArenaStringPtr rpm_to_pwm_;
  ::google::protobuf::internal::ArenaStringPtr pwm_path_;
  ::google::protobuf::internal::ArenaStringPtr rpm_path_;
  ::google::protobuf::internal::ArenaStringPtr enable_path_;
  int type_;
  ::google::protobuf::uint32 start_pwm_;
  ::google::protobuf::uint64 interval_;
  bool ignore_;
  ::google::protobuf::int32 driver_flag_;
  ::google::protobuf::uint32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_DevicesSpec_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Sensor
    : public ::google::protobuf::
          Message /* @@protoc_insertion_point(class_definition:fc_pb.Sensor)
                   */
{
public:
  Sensor();
  virtual ~Sensor();

  Sensor(const Sensor &from);

  inline Sensor &operator=(const Sensor &from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  Sensor(Sensor &&from) noexcept : Sensor() { *this = ::std::move(from); }

  inline Sensor &operator=(Sensor &&from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from)
        InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  static const ::google::protobuf::Descriptor *descriptor();
  static const Sensor &default_instance();

  static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
  static inline const Sensor *internal_default_instance() {
    return reinterpret_cast<const Sensor *>(&_Sensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;

  void Swap(Sensor *other);
  friend void swap(Sensor &a, Sensor &b) { a.Swap(&b); }

  // implements Message ----------------------------------------------

  inline Sensor *New() const final { return CreateMaybeMessage<Sensor>(NULL); }

  Sensor *New(::google::protobuf::Arena *arena) const final {
    return CreateMaybeMessage<Sensor>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message &from) final;
  void MergeFrom(const ::google::protobuf::Message &from) final;
  void CopyFrom(const Sensor &from);
  void MergeFrom(const Sensor &from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const final;
  ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8 *target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sensor *other);

private:
  inline ::google::protobuf::Arena *GetArenaNoVirtual() const { return NULL; }
  inline void *MaybeArenaPtr() const { return NULL; }

public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string label = 2;
  void clear_label();
  static const int kLabelFieldNumber = 2;
  const ::std::string &label() const;
  void set_label(const ::std::string &value);
#if LANG_CXX11
  void set_label(::std::string &&value);
#endif
  void set_label(const char *value);
  void set_label(const char *value, size_t size);
  ::std::string *mutable_label();
  ::std::string *release_label();
  void set_allocated_label(::std::string *label);

  // string input_path = 10;
  void clear_input_path();
  static const int kInputPathFieldNumber = 10;
  const ::std::string &input_path() const;
  void set_input_path(const ::std::string &value);
#if LANG_CXX11
  void set_input_path(::std::string &&value);
#endif
  void set_input_path(const char *value);
  void set_input_path(const char *value, size_t size);
  ::std::string *mutable_input_path();
  ::std::string *release_input_path();
  void set_allocated_input_path(::std::string *input_path);

  // string enable_path = 11;
  void clear_enable_path();
  static const int kEnablePathFieldNumber = 11;
  const ::std::string &enable_path() const;
  void set_enable_path(const ::std::string &value);
#if LANG_CXX11
  void set_enable_path(::std::string &&value);
#endif
  void set_enable_path(const char *value);
  void set_enable_path(const char *value, size_t size);
  ::std::string *mutable_enable_path();
  ::std::string *release_enable_path();
  void set_allocated_enable_path(::std::string *enable_path);

  // string fault_path = 12;
  void clear_fault_path();
  static const int kFaultPathFieldNumber = 12;
  const ::std::string &fault_path() const;
  void set_fault_path(const ::std::string &value);
#if LANG_CXX11
  void set_fault_path(::std::string &&value);
#endif
  void set_fault_path(const char *value);
  void set_fault_path(const char *value, size_t size);
  ::std::string *mutable_fault_path();
  ::std::string *release_fault_path();
  void set_allocated_fault_path(::std::string *fault_path);

  // string min_path = 13;
  void clear_min_path();
  static const int kMinPathFieldNumber = 13;
  const ::std::string &min_path() const;
  void set_min_path(const ::std::string &value);
#if LANG_CXX11
  void set_min_path(::std::string &&value);
#endif
  void set_min_path(const char *value);
  void set_min_path(const char *value, size_t size);
  ::std::string *mutable_min_path();
  ::std::string *release_min_path();
  void set_allocated_min_path(::std::string *min_path);

  // string max_path = 14;
  void clear_max_path();
  static const int kMaxPathFieldNumber = 14;
  const ::std::string &max_path() const;
  void set_max_path(const ::std::string &value);
#if LANG_CXX11
  void set_max_path(::std::string &&value);
#endif
  void set_max_path(const char *value);
  void set_max_path(const char *value, size_t size);
  ::std::string *mutable_max_path();
  ::std::string *release_max_path();
  void set_allocated_max_path(::std::string *max_path);

  // string crit_path = 15;
  void clear_crit_path();
  static const int kCritPathFieldNumber = 15;
  const ::std::string &crit_path() const;
  void set_crit_path(const ::std::string &value);
#if LANG_CXX11
  void set_crit_path(::std::string &&value);
#endif
  void set_crit_path(const char *value);
  void set_crit_path(const char *value, size_t size);
  ::std::string *mutable_crit_path();
  ::std::string *release_crit_path();
  void set_allocated_crit_path(::std::string *crit_path);

  // .fc_pb.DevType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::fc_pb::DevType type() const;
  void set_type(::fc_pb::DevType value);

  // int32 id = 20;
  void clear_id();
  static const int kIdFieldNumber = 20;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fc_pb.Sensor)
private:
  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::google::protobuf::internal::ArenaStringPtr input_path_;
  ::google::protobuf::internal::ArenaStringPtr enable_path_;
  ::google::protobuf::internal::ArenaStringPtr fault_path_;
  ::google::protobuf::internal::ArenaStringPtr min_path_;
  ::google::protobuf::internal::ArenaStringPtr max_path_;
  ::google::protobuf::internal::ArenaStringPtr crit_path_;
  int type_;
  ::google::protobuf::int32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_DevicesSpec_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DevicesRequest
    : public ::google::protobuf::
          Message /* @@protoc_insertion_point(class_definition:fc_pb.DevicesRequest)
                   */
{
public:
  DevicesRequest();
  virtual ~DevicesRequest();

  DevicesRequest(const DevicesRequest &from);

  inline DevicesRequest &operator=(const DevicesRequest &from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  DevicesRequest(DevicesRequest &&from) noexcept : DevicesRequest() {
    *this = ::std::move(from);
  }

  inline DevicesRequest &operator=(DevicesRequest &&from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from)
        InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  static const ::google::protobuf::Descriptor *descriptor();
  static const DevicesRequest &default_instance();

  static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
  static inline const DevicesRequest *internal_default_instance() {
    return reinterpret_cast<const DevicesRequest *>(
        &_DevicesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;

  void Swap(DevicesRequest *other);
  friend void swap(DevicesRequest &a, DevicesRequest &b) { a.Swap(&b); }

  // implements Message ----------------------------------------------

  inline DevicesRequest *New() const final {
    return CreateMaybeMessage<DevicesRequest>(NULL);
  }

  DevicesRequest *New(::google::protobuf::Arena *arena) const final {
    return CreateMaybeMessage<DevicesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message &from) final;
  void MergeFrom(const ::google::protobuf::Message &from) final;
  void CopyFrom(const DevicesRequest &from);
  void MergeFrom(const DevicesRequest &from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const final;
  ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8 *target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DevicesRequest *other);

private:
  inline ::google::protobuf::Arena *GetArenaNoVirtual() const { return NULL; }
  inline void *MaybeArenaPtr() const { return NULL; }

public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool include_unsupported = 1;
  void clear_include_unsupported();
  static const int kIncludeUnsupportedFieldNumber = 1;
  bool include_unsupported() const;
  void set_include_unsupported(bool value);

  // @@protoc_insertion_point(class_scope:fc_pb.DevicesRequest)
private:
  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool include_unsupported_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_DevicesSpec_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ControllerState
    : public ::google::protobuf::
          Message /* @@protoc_insertion_point(class_definition:fc_pb.ControllerState)
                   */
{
public:
  ControllerState();
  virtual ~ControllerState();

  ControllerState(const ControllerState &from);

  inline ControllerState &operator=(const ControllerState &from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  ControllerState(ControllerState &&from) noexcept : ControllerState() {
    *this = ::std::move(from);
  }

  inline ControllerState &operator=(ControllerState &&from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from)
        InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  static const ::google::protobuf::Descriptor *descriptor();
  static const ControllerState &default_instance();

  static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
  static inline const ControllerState *internal_default_instance() {
    return reinterpret_cast<const ControllerState *>(
        &_ControllerState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;

  void Swap(ControllerState *other);
  friend void swap(ControllerState &a, ControllerState &b) { a.Swap(&b); }

  // implements Message ----------------------------------------------

  inline ControllerState *New() const final {
    return CreateMaybeMessage<ControllerState>(NULL);
  }

  ControllerState *New(::google::protobuf::Arena *arena) const final {
    return CreateMaybeMessage<ControllerState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message &from) final;
  void MergeFrom(const ::google::protobuf::Message &from) final;
  void CopyFrom(const ControllerState &from);
  void MergeFrom(const ControllerState &from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const final;
  ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8 *target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControllerState *other);

private:
  inline ::google::protobuf::Arena *GetArenaNoVirtual() const { return NULL; }
  inline void *MaybeArenaPtr() const { return NULL; }

public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ControllerState_State State;
  static const State STOP = ControllerState_State_STOP;
  static const State RUN = ControllerState_State_RUN;
  static const State RESTART = ControllerState_State_RESTART;
  static const State TEST = ControllerState_State_TEST;
  static inline bool State_IsValid(int value) {
    return ControllerState_State_IsValid(value);
  }
  static const State State_MIN = ControllerState_State_State_MIN;
  static const State State_MAX = ControllerState_State_State_MAX;
  static const int State_ARRAYSIZE = ControllerState_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor *State_descriptor() {
    return ControllerState_State_descriptor();
  }
  static inline const ::std::string &State_Name(State value) {
    return ControllerState_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string &name, State *value) {
    return ControllerState_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .fc_pb.ControllerState.State state = 1;
  void clear_state();
  static const int kStateFieldNumber = 1;
  ::fc_pb::ControllerState_State state() const;
  void set_state(::fc_pb::ControllerState_State value);

  // @@protoc_insertion_point(class_scope:fc_pb.ControllerState)
private:
  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int state_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_DevicesSpec_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Empty
    : public ::google::protobuf::
          Message /* @@protoc_insertion_point(class_definition:fc_pb.Empty) */ {
public:
  Empty();
  virtual ~Empty();

  Empty(const Empty &from);

  inline Empty &operator=(const Empty &from) {
    CopyFrom(from);
    return *this;
  }
#if LANG_CXX11
  Empty(Empty &&from) noexcept : Empty() { *this = ::std::move(from); }

  inline Empty &operator=(Empty &&from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from)
        InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
#endif
  static const ::google::protobuf::Descriptor *descriptor();
  static const Empty &default_instance();

  static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
  static inline const Empty *internal_default_instance() {
    return reinterpret_cast<const Empty *>(&_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;

  void Swap(Empty *other);
  friend void swap(Empty &a, Empty &b) { a.Swap(&b); }

  // implements Message ----------------------------------------------

  inline Empty *New() const final { return CreateMaybeMessage<Empty>(NULL); }

  Empty *New(::google::protobuf::Arena *arena) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message &from) final;
  void MergeFrom(const ::google::protobuf::Message &from) final;
  void CopyFrom(const Empty &from);
  void MergeFrom(const Empty &from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream *input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream *output) const final;
  ::google::protobuf::uint8 *InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8 *target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Empty *other);

private:
  inline ::google::protobuf::Arena *GetArenaNoVirtual() const { return NULL; }
  inline void *MaybeArenaPtr() const { return NULL; }

public:
  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fc_pb.Empty)
private:
  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_DevicesSpec_2eproto::TableStruct;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// Controller

// .fc_pb.ControllerConfig config = 1;
inline bool Controller::has_config() const {
  return this != internal_default_instance() && config_ != NULL;
}
inline void Controller::clear_config() {
  if (GetArenaNoVirtual() == NULL && config_ != NULL) {
    delete config_;
  }
  config_ = NULL;
}
inline const ::fc_pb::ControllerConfig &Controller::_internal_config() const {
  return *config_;
}
inline const ::fc_pb::ControllerConfig &Controller::config() const {
  const ::fc_pb::ControllerConfig *p = config_;
  // @@protoc_insertion_point(field_get:fc_pb.Controller.config)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::fc_pb::ControllerConfig *>(
                         &::fc_pb::_ControllerConfig_default_instance_);
}
inline ::fc_pb::ControllerConfig *Controller::release_config() {
  // @@protoc_insertion_point(field_release:fc_pb.Controller.config)

  ::fc_pb::ControllerConfig *temp = config_;
  config_ = NULL;
  return temp;
}
inline ::fc_pb::ControllerConfig *Controller::mutable_config() {

  if (config_ == NULL) {
    auto *p =
        CreateMaybeMessage<::fc_pb::ControllerConfig>(GetArenaNoVirtual());
    config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:fc_pb.Controller.config)
  return config_;
}
inline void
Controller::set_allocated_config(::fc_pb::ControllerConfig *config) {
  ::google::protobuf::Arena *message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete config_;
  }
  if (config) {
    ::google::protobuf::Arena *submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }

  } else {
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:fc_pb.Controller.config)
}

// .fc_pb.Devices devices = 2;
inline bool Controller::has_devices() const {
  return this != internal_default_instance() && devices_ != NULL;
}
inline void Controller::clear_devices() {
  if (GetArenaNoVirtual() == NULL && devices_ != NULL) {
    delete devices_;
  }
  devices_ = NULL;
}
inline const ::fc_pb::Devices &Controller::_internal_devices() const {
  return *devices_;
}
inline const ::fc_pb::Devices &Controller::devices() const {
  const ::fc_pb::Devices *p = devices_;
  // @@protoc_insertion_point(field_get:fc_pb.Controller.devices)
  return p != NULL ? *p
                   : *reinterpret_cast<const ::fc_pb::Devices *>(
                         &::fc_pb::_Devices_default_instance_);
}
inline ::fc_pb::Devices *Controller::release_devices() {
  // @@protoc_insertion_point(field_release:fc_pb.Controller.devices)

  ::fc_pb::Devices *temp = devices_;
  devices_ = NULL;
  return temp;
}
inline ::fc_pb::Devices *Controller::mutable_devices() {

  if (devices_ == NULL) {
    auto *p = CreateMaybeMessage<::fc_pb::Devices>(GetArenaNoVirtual());
    devices_ = p;
  }
  // @@protoc_insertion_point(field_mutable:fc_pb.Controller.devices)
  return devices_;
}
inline void Controller::set_allocated_devices(::fc_pb::Devices *devices) {
  ::google::protobuf::Arena *message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete devices_;
  }
  if (devices) {
    ::google::protobuf::Arena *submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      devices = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, devices, submessage_arena);
    }

  } else {
  }
  devices_ = devices;
  // @@protoc_insertion_point(field_set_allocated:fc_pb.Controller.devices)
}

// -------------------------------------------------------------------

// ControllerConfig

// uint32 update_interval = 1;
inline void ControllerConfig::clear_update_interval() { update_interval_ = 0u; }
inline ::google::protobuf::uint32 ControllerConfig::update_interval() const {
  // @@protoc_insertion_point(field_get:fc_pb.ControllerConfig.update_interval)
  return update_interval_;
}
inline void
ControllerConfig::set_update_interval(::google::protobuf::uint32 value) {

  update_interval_ = value;
  // @@protoc_insertion_point(field_set:fc_pb.ControllerConfig.update_interval)
}

// bool dynamic = 2;
inline void ControllerConfig::clear_dynamic() { dynamic_ = false; }
inline bool ControllerConfig::dynamic() const {
  // @@protoc_insertion_point(field_get:fc_pb.ControllerConfig.dynamic)
  return dynamic_;
}
inline void ControllerConfig::set_dynamic(bool value) {

  dynamic_ = value;
  // @@protoc_insertion_point(field_set:fc_pb.ControllerConfig.dynamic)
}

// uint32 smoothing_intervals = 3;
inline void ControllerConfig::clear_smoothing_intervals() {
  smoothing_intervals_ = 0u;
}
inline ::google::protobuf::uint32
ControllerConfig::smoothing_intervals() const {
  // @@protoc_insertion_point(field_get:fc_pb.ControllerConfig.smoothing_intervals)
  return smoothing_intervals_;
}
inline void
ControllerConfig::set_smoothing_intervals(::google::protobuf::uint32 value) {

  smoothing_intervals_ = value;
  // @@protoc_insertion_point(field_set:fc_pb.ControllerConfig.smoothing_intervals)
}

// uint32 top_stickiness_intervals = 4;
inline void ControllerConfig::clear_top_stickiness_intervals() {
  top_stickiness_intervals_ = 0u;
}
inline ::google::protobuf::uint32
ControllerConfig::top_stickiness_intervals() const {
  // @@protoc_insertion_point(field_get:fc_pb.ControllerConfig.top_stickiness_intervals)
  return top_stickiness_intervals_;
}
inline void ControllerConfig::set_top_stickiness_intervals(
    ::google::protobuf::uint32 value) {

  top_stickiness_intervals_ = value;
  // @@protoc_insertion_point(field_set:fc_pb.ControllerConfig.top_stickiness_intervals)
}

// uint32 temp_averaging_intervals = 5;
inline void ControllerConfig::clear_temp_averaging_intervals() {
  temp_averaging_intervals_ = 0u;
}
inline ::google::protobuf::uint32
ControllerConfig::temp_averaging_intervals() const {
  // @@protoc_insertion_point(field_get:fc_pb.ControllerConfig.temp_averaging_intervals)
  return temp_averaging_intervals_;
}
inline void ControllerConfig::set_temp_averaging_intervals(
    ::google::protobuf::uint32 value) {

  temp_averaging_intervals_ = value;
  // @@protoc_insertion_point(field_set:fc_pb.ControllerConfig.temp_averaging_intervals)
}

// -------------------------------------------------------------------

// Devices

// repeated .fc_pb.Fan fan = 1;
inline int Devices::fan_size() const { return fan_.size(); }
inline void Devices::clear_fan() { fan_.Clear(); }
inline ::fc_pb::Fan *Devices::mutable_fan(int index) {
  // @@protoc_insertion_point(field_mutable:fc_pb.Devices.fan)
  return fan_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::fc_pb::Fan> *
Devices::mutable_fan() {
  // @@protoc_insertion_point(field_mutable_list:fc_pb.Devices.fan)
  return &fan_;
}
inline const ::fc_pb::Fan &Devices::fan(int index) const {
  // @@protoc_insertion_point(field_get:fc_pb.Devices.fan)
  return fan_.Get(index);
}
inline ::fc_pb::Fan *Devices::add_fan() {
  // @@protoc_insertion_point(field_add:fc_pb.Devices.fan)
  return fan_.Add();
}
inline const ::google::protobuf::RepeatedPtrField<::fc_pb::Fan> &
Devices::fan() const {
  // @@protoc_insertion_point(field_list:fc_pb.Devices.fan)
  return fan_;
}

// repeated .fc_pb.Sensor sensor = 2;
inline int Devices::sensor_size() const { return sensor_.size(); }
inline void Devices::clear_sensor() { sensor_.Clear(); }
inline ::fc_pb::Sensor *Devices::mutable_sensor(int index) {
  // @@protoc_insertion_point(field_mutable:fc_pb.Devices.sensor)
  return sensor_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::fc_pb::Sensor> *
Devices::mutable_sensor() {
  // @@protoc_insertion_point(field_mutable_list:fc_pb.Devices.sensor)
  return &sensor_;
}
inline const ::fc_pb::Sensor &Devices::sensor(int index) const {
  // @@protoc_insertion_point(field_get:fc_pb.Devices.sensor)
  return sensor_.Get(index);
}
inline ::fc_pb::Sensor *Devices::add_sensor() {
  // @@protoc_insertion_point(field_add:fc_pb.Devices.sensor)
  return sensor_.Add();
}
inline const ::google::protobuf::RepeatedPtrField<::fc_pb::Sensor> &
Devices::sensor() const {
  // @@protoc_insertion_point(field_list:fc_pb.Devices.sensor)
  return sensor_;
}

// -------------------------------------------------------------------

// Fan

// .fc_pb.DevType type = 1;
inline void Fan::clear_type() { type_ = 0; }
inline ::fc_pb::DevType Fan::type() const {
  // @@protoc_insertion_point(field_get:fc_pb.Fan.type)
  return static_cast<::fc_pb::DevType>(type_);
}
inline void Fan::set_type(::fc_pb::DevType value) {

  type_ = value;
  // @@protoc_insertion_point(field_set:fc_pb.Fan.type)
}

// string label = 2;
inline void Fan::clear_label() {
  label_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string &Fan::label() const {
  // @@protoc_insertion_point(field_get:fc_pb.Fan.label)
  return label_.GetNoArena();
}
inline void Fan::set_label(const ::std::string &value) {

  label_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fc_pb.Fan.label)
}
#if LANG_CXX11
inline void Fan::set_label(::std::string &&value) {

  label_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fc_pb.Fan.label)
}
#endif
inline void Fan::set_label(const char *value) {
  GOOGLE_DCHECK(value != NULL);

  label_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fc_pb.Fan.label)
}
inline void Fan::set_label(const char *value, size_t size) {

  label_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char *>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fc_pb.Fan.label)
}
inline ::std::string *Fan::mutable_label() {

  // @@protoc_insertion_point(field_mutable:fc_pb.Fan.label)
  return label_.MutableNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string *Fan::release_label() {
  // @@protoc_insertion_point(field_release:fc_pb.Fan.label)

  return label_.ReleaseNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Fan::set_allocated_label(::std::string *label) {
  if (label != NULL) {

  } else {
  }
  label_.SetAllocatedNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:fc_pb.Fan.label)
}

// string sensor = 3;
inline void Fan::clear_sensor() {
  sensor_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string &Fan::sensor() const {
  // @@protoc_insertion_point(field_get:fc_pb.Fan.sensor)
  return sensor_.GetNoArena();
}
inline void Fan::set_sensor(const ::std::string &value) {

  sensor_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fc_pb.Fan.sensor)
}
#if LANG_CXX11
inline void Fan::set_sensor(::std::string &&value) {

  sensor_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fc_pb.Fan.sensor)
}
#endif
inline void Fan::set_sensor(const char *value) {
  GOOGLE_DCHECK(value != NULL);

  sensor_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fc_pb.Fan.sensor)
}
inline void Fan::set_sensor(const char *value, size_t size) {

  sensor_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char *>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fc_pb.Fan.sensor)
}
inline ::std::string *Fan::mutable_sensor() {

  // @@protoc_insertion_point(field_mutable:fc_pb.Fan.sensor)
  return sensor_.MutableNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string *Fan::release_sensor() {
  // @@protoc_insertion_point(field_release:fc_pb.Fan.sensor)

  return sensor_.ReleaseNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Fan::set_allocated_sensor(::std::string *sensor) {
  if (sensor != NULL) {

  } else {
  }
  sensor_.SetAllocatedNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), sensor);
  // @@protoc_insertion_point(field_set_allocated:fc_pb.Fan.sensor)
}

// string temp_to_rpm = 4;
inline void Fan::clear_temp_to_rpm() {
  temp_to_rpm_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string &Fan::temp_to_rpm() const {
  // @@protoc_insertion_point(field_get:fc_pb.Fan.temp_to_rpm)
  return temp_to_rpm_.GetNoArena();
}
inline void Fan::set_temp_to_rpm(const ::std::string &value) {

  temp_to_rpm_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fc_pb.Fan.temp_to_rpm)
}
#if LANG_CXX11
inline void Fan::set_temp_to_rpm(::std::string &&value) {

  temp_to_rpm_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fc_pb.Fan.temp_to_rpm)
}
#endif
inline void Fan::set_temp_to_rpm(const char *value) {
  GOOGLE_DCHECK(value != NULL);

  temp_to_rpm_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fc_pb.Fan.temp_to_rpm)
}
inline void Fan::set_temp_to_rpm(const char *value, size_t size) {

  temp_to_rpm_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char *>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fc_pb.Fan.temp_to_rpm)
}
inline ::std::string *Fan::mutable_temp_to_rpm() {

  // @@protoc_insertion_point(field_mutable:fc_pb.Fan.temp_to_rpm)
  return temp_to_rpm_.MutableNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string *Fan::release_temp_to_rpm() {
  // @@protoc_insertion_point(field_release:fc_pb.Fan.temp_to_rpm)

  return temp_to_rpm_.ReleaseNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Fan::set_allocated_temp_to_rpm(::std::string *temp_to_rpm) {
  if (temp_to_rpm != NULL) {

  } else {
  }
  temp_to_rpm_.SetAllocatedNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      temp_to_rpm);
  // @@protoc_insertion_point(field_set_allocated:fc_pb.Fan.temp_to_rpm)
}

// string rpm_to_pwm = 5;
inline void Fan::clear_rpm_to_pwm() {
  rpm_to_pwm_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string &Fan::rpm_to_pwm() const {
  // @@protoc_insertion_point(field_get:fc_pb.Fan.rpm_to_pwm)
  return rpm_to_pwm_.GetNoArena();
}
inline void Fan::set_rpm_to_pwm(const ::std::string &value) {

  rpm_to_pwm_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fc_pb.Fan.rpm_to_pwm)
}
#if LANG_CXX11
inline void Fan::set_rpm_to_pwm(::std::string &&value) {

  rpm_to_pwm_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fc_pb.Fan.rpm_to_pwm)
}
#endif
inline void Fan::set_rpm_to_pwm(const char *value) {
  GOOGLE_DCHECK(value != NULL);

  rpm_to_pwm_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fc_pb.Fan.rpm_to_pwm)
}
inline void Fan::set_rpm_to_pwm(const char *value, size_t size) {

  rpm_to_pwm_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char *>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fc_pb.Fan.rpm_to_pwm)
}
inline ::std::string *Fan::mutable_rpm_to_pwm() {

  // @@protoc_insertion_point(field_mutable:fc_pb.Fan.rpm_to_pwm)
  return rpm_to_pwm_.MutableNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string *Fan::release_rpm_to_pwm() {
  // @@protoc_insertion_point(field_release:fc_pb.Fan.rpm_to_pwm)

  return rpm_to_pwm_.ReleaseNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Fan::set_allocated_rpm_to_pwm(::std::string *rpm_to_pwm) {
  if (rpm_to_pwm != NULL) {

  } else {
  }
  rpm_to_pwm_.SetAllocatedNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), rpm_to_pwm);
  // @@protoc_insertion_point(field_set_allocated:fc_pb.Fan.rpm_to_pwm)
}

// uint32 start_pwm = 6;
inline void Fan::clear_start_pwm() { start_pwm_ = 0u; }
inline ::google::protobuf::uint32 Fan::start_pwm() const {
  // @@protoc_insertion_point(field_get:fc_pb.Fan.start_pwm)
  return start_pwm_;
}
inline void Fan::set_start_pwm(::google::protobuf::uint32 value) {

  start_pwm_ = value;
  // @@protoc_insertion_point(field_set:fc_pb.Fan.start_pwm)
}

// uint64 interval = 7;
inline void Fan::clear_interval() { interval_ = GOOGLE_ULONGLONG(0); }
inline ::google::protobuf::uint64 Fan::interval() const {
  // @@protoc_insertion_point(field_get:fc_pb.Fan.interval)
  return interval_;
}
inline void Fan::set_interval(::google::protobuf::uint64 value) {

  interval_ = value;
  // @@protoc_insertion_point(field_set:fc_pb.Fan.interval)
}

// bool ignore = 8;
inline void Fan::clear_ignore() { ignore_ = false; }
inline bool Fan::ignore() const {
  // @@protoc_insertion_point(field_get:fc_pb.Fan.ignore)
  return ignore_;
}
inline void Fan::set_ignore(bool value) {

  ignore_ = value;
  // @@protoc_insertion_point(field_set:fc_pb.Fan.ignore)
}

// string pwm_path = 10;
inline void Fan::clear_pwm_path() {
  pwm_path_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string &Fan::pwm_path() const {
  // @@protoc_insertion_point(field_get:fc_pb.Fan.pwm_path)
  return pwm_path_.GetNoArena();
}
inline void Fan::set_pwm_path(const ::std::string &value) {

  pwm_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fc_pb.Fan.pwm_path)
}
#if LANG_CXX11
inline void Fan::set_pwm_path(::std::string &&value) {

  pwm_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fc_pb.Fan.pwm_path)
}
#endif
inline void Fan::set_pwm_path(const char *value) {
  GOOGLE_DCHECK(value != NULL);

  pwm_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fc_pb.Fan.pwm_path)
}
inline void Fan::set_pwm_path(const char *value, size_t size) {

  pwm_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char *>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fc_pb.Fan.pwm_path)
}
inline ::std::string *Fan::mutable_pwm_path() {

  // @@protoc_insertion_point(field_mutable:fc_pb.Fan.pwm_path)
  return pwm_path_.MutableNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string *Fan::release_pwm_path() {
  // @@protoc_insertion_point(field_release:fc_pb.Fan.pwm_path)

  return pwm_path_.ReleaseNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Fan::set_allocated_pwm_path(::std::string *pwm_path) {
  if (pwm_path != NULL) {

  } else {
  }
  pwm_path_.SetAllocatedNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), pwm_path);
  // @@protoc_insertion_point(field_set_allocated:fc_pb.Fan.pwm_path)
}

// string rpm_path = 11;
inline void Fan::clear_rpm_path() {
  rpm_path_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string &Fan::rpm_path() const {
  // @@protoc_insertion_point(field_get:fc_pb.Fan.rpm_path)
  return rpm_path_.GetNoArena();
}
inline void Fan::set_rpm_path(const ::std::string &value) {

  rpm_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fc_pb.Fan.rpm_path)
}
#if LANG_CXX11
inline void Fan::set_rpm_path(::std::string &&value) {

  rpm_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fc_pb.Fan.rpm_path)
}
#endif
inline void Fan::set_rpm_path(const char *value) {
  GOOGLE_DCHECK(value != NULL);

  rpm_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fc_pb.Fan.rpm_path)
}
inline void Fan::set_rpm_path(const char *value, size_t size) {

  rpm_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char *>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fc_pb.Fan.rpm_path)
}
inline ::std::string *Fan::mutable_rpm_path() {

  // @@protoc_insertion_point(field_mutable:fc_pb.Fan.rpm_path)
  return rpm_path_.MutableNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string *Fan::release_rpm_path() {
  // @@protoc_insertion_point(field_release:fc_pb.Fan.rpm_path)

  return rpm_path_.ReleaseNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Fan::set_allocated_rpm_path(::std::string *rpm_path) {
  if (rpm_path != NULL) {

  } else {
  }
  rpm_path_.SetAllocatedNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), rpm_path);
  // @@protoc_insertion_point(field_set_allocated:fc_pb.Fan.rpm_path)
}

// string enable_path = 12;
inline void Fan::clear_enable_path() {
  enable_path_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string &Fan::enable_path() const {
  // @@protoc_insertion_point(field_get:fc_pb.Fan.enable_path)
  return enable_path_.GetNoArena();
}
inline void Fan::set_enable_path(const ::std::string &value) {

  enable_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fc_pb.Fan.enable_path)
}
#if LANG_CXX11
inline void Fan::set_enable_path(::std::string &&value) {

  enable_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fc_pb.Fan.enable_path)
}
#endif
inline void Fan::set_enable_path(const char *value) {
  GOOGLE_DCHECK(value != NULL);

  enable_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fc_pb.Fan.enable_path)
}
inline void Fan::set_enable_path(const char *value, size_t size) {

  enable_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char *>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fc_pb.Fan.enable_path)
}
inline ::std::string *Fan::mutable_enable_path() {

  // @@protoc_insertion_point(field_mutable:fc_pb.Fan.enable_path)
  return enable_path_.MutableNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string *Fan::release_enable_path() {
  // @@protoc_insertion_point(field_release:fc_pb.Fan.enable_path)

  return enable_path_.ReleaseNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Fan::set_allocated_enable_path(::std::string *enable_path) {
  if (enable_path != NULL) {

  } else {
  }
  enable_path_.SetAllocatedNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      enable_path);
  // @@protoc_insertion_point(field_set_allocated:fc_pb.Fan.enable_path)
}

// int32 driver_flag = 13;
inline void Fan::clear_driver_flag() { driver_flag_ = 0; }
inline ::google::protobuf::int32 Fan::driver_flag() const {
  // @@protoc_insertion_point(field_get:fc_pb.Fan.driver_flag)
  return driver_flag_;
}
inline void Fan::set_driver_flag(::google::protobuf::int32 value) {

  driver_flag_ = value;
  // @@protoc_insertion_point(field_set:fc_pb.Fan.driver_flag)
}

// uint32 id = 20;
inline void Fan::clear_id() { id_ = 0u; }
inline ::google::protobuf::uint32 Fan::id() const {
  // @@protoc_insertion_point(field_get:fc_pb.Fan.id)
  return id_;
}
inline void Fan::set_id(::google::protobuf::uint32 value) {

  id_ = value;
  // @@protoc_insertion_point(field_set:fc_pb.Fan.id)
}

// -------------------------------------------------------------------

// Sensor

// .fc_pb.DevType type = 1;
inline void Sensor::clear_type() { type_ = 0; }
inline ::fc_pb::DevType Sensor::type() const {
  // @@protoc_insertion_point(field_get:fc_pb.Sensor.type)
  return static_cast<::fc_pb::DevType>(type_);
}
inline void Sensor::set_type(::fc_pb::DevType value) {

  type_ = value;
  // @@protoc_insertion_point(field_set:fc_pb.Sensor.type)
}

// string label = 2;
inline void Sensor::clear_label() {
  label_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string &Sensor::label() const {
  // @@protoc_insertion_point(field_get:fc_pb.Sensor.label)
  return label_.GetNoArena();
}
inline void Sensor::set_label(const ::std::string &value) {

  label_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fc_pb.Sensor.label)
}
#if LANG_CXX11
inline void Sensor::set_label(::std::string &&value) {

  label_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fc_pb.Sensor.label)
}
#endif
inline void Sensor::set_label(const char *value) {
  GOOGLE_DCHECK(value != NULL);

  label_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fc_pb.Sensor.label)
}
inline void Sensor::set_label(const char *value, size_t size) {

  label_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char *>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fc_pb.Sensor.label)
}
inline ::std::string *Sensor::mutable_label() {

  // @@protoc_insertion_point(field_mutable:fc_pb.Sensor.label)
  return label_.MutableNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string *Sensor::release_label() {
  // @@protoc_insertion_point(field_release:fc_pb.Sensor.label)

  return label_.ReleaseNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sensor::set_allocated_label(::std::string *label) {
  if (label != NULL) {

  } else {
  }
  label_.SetAllocatedNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:fc_pb.Sensor.label)
}

// string input_path = 10;
inline void Sensor::clear_input_path() {
  input_path_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string &Sensor::input_path() const {
  // @@protoc_insertion_point(field_get:fc_pb.Sensor.input_path)
  return input_path_.GetNoArena();
}
inline void Sensor::set_input_path(const ::std::string &value) {

  input_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fc_pb.Sensor.input_path)
}
#if LANG_CXX11
inline void Sensor::set_input_path(::std::string &&value) {

  input_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fc_pb.Sensor.input_path)
}
#endif
inline void Sensor::set_input_path(const char *value) {
  GOOGLE_DCHECK(value != NULL);

  input_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fc_pb.Sensor.input_path)
}
inline void Sensor::set_input_path(const char *value, size_t size) {

  input_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char *>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fc_pb.Sensor.input_path)
}
inline ::std::string *Sensor::mutable_input_path() {

  // @@protoc_insertion_point(field_mutable:fc_pb.Sensor.input_path)
  return input_path_.MutableNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string *Sensor::release_input_path() {
  // @@protoc_insertion_point(field_release:fc_pb.Sensor.input_path)

  return input_path_.ReleaseNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sensor::set_allocated_input_path(::std::string *input_path) {
  if (input_path != NULL) {

  } else {
  }
  input_path_.SetAllocatedNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), input_path);
  // @@protoc_insertion_point(field_set_allocated:fc_pb.Sensor.input_path)
}

// string enable_path = 11;
inline void Sensor::clear_enable_path() {
  enable_path_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string &Sensor::enable_path() const {
  // @@protoc_insertion_point(field_get:fc_pb.Sensor.enable_path)
  return enable_path_.GetNoArena();
}
inline void Sensor::set_enable_path(const ::std::string &value) {

  enable_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fc_pb.Sensor.enable_path)
}
#if LANG_CXX11
inline void Sensor::set_enable_path(::std::string &&value) {

  enable_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fc_pb.Sensor.enable_path)
}
#endif
inline void Sensor::set_enable_path(const char *value) {
  GOOGLE_DCHECK(value != NULL);

  enable_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fc_pb.Sensor.enable_path)
}
inline void Sensor::set_enable_path(const char *value, size_t size) {

  enable_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char *>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fc_pb.Sensor.enable_path)
}
inline ::std::string *Sensor::mutable_enable_path() {

  // @@protoc_insertion_point(field_mutable:fc_pb.Sensor.enable_path)
  return enable_path_.MutableNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string *Sensor::release_enable_path() {
  // @@protoc_insertion_point(field_release:fc_pb.Sensor.enable_path)

  return enable_path_.ReleaseNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sensor::set_allocated_enable_path(::std::string *enable_path) {
  if (enable_path != NULL) {

  } else {
  }
  enable_path_.SetAllocatedNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      enable_path);
  // @@protoc_insertion_point(field_set_allocated:fc_pb.Sensor.enable_path)
}

// string fault_path = 12;
inline void Sensor::clear_fault_path() {
  fault_path_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string &Sensor::fault_path() const {
  // @@protoc_insertion_point(field_get:fc_pb.Sensor.fault_path)
  return fault_path_.GetNoArena();
}
inline void Sensor::set_fault_path(const ::std::string &value) {

  fault_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fc_pb.Sensor.fault_path)
}
#if LANG_CXX11
inline void Sensor::set_fault_path(::std::string &&value) {

  fault_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fc_pb.Sensor.fault_path)
}
#endif
inline void Sensor::set_fault_path(const char *value) {
  GOOGLE_DCHECK(value != NULL);

  fault_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fc_pb.Sensor.fault_path)
}
inline void Sensor::set_fault_path(const char *value, size_t size) {

  fault_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char *>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fc_pb.Sensor.fault_path)
}
inline ::std::string *Sensor::mutable_fault_path() {

  // @@protoc_insertion_point(field_mutable:fc_pb.Sensor.fault_path)
  return fault_path_.MutableNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string *Sensor::release_fault_path() {
  // @@protoc_insertion_point(field_release:fc_pb.Sensor.fault_path)

  return fault_path_.ReleaseNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sensor::set_allocated_fault_path(::std::string *fault_path) {
  if (fault_path != NULL) {

  } else {
  }
  fault_path_.SetAllocatedNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), fault_path);
  // @@protoc_insertion_point(field_set_allocated:fc_pb.Sensor.fault_path)
}

// string min_path = 13;
inline void Sensor::clear_min_path() {
  min_path_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string &Sensor::min_path() const {
  // @@protoc_insertion_point(field_get:fc_pb.Sensor.min_path)
  return min_path_.GetNoArena();
}
inline void Sensor::set_min_path(const ::std::string &value) {

  min_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fc_pb.Sensor.min_path)
}
#if LANG_CXX11
inline void Sensor::set_min_path(::std::string &&value) {

  min_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fc_pb.Sensor.min_path)
}
#endif
inline void Sensor::set_min_path(const char *value) {
  GOOGLE_DCHECK(value != NULL);

  min_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fc_pb.Sensor.min_path)
}
inline void Sensor::set_min_path(const char *value, size_t size) {

  min_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char *>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fc_pb.Sensor.min_path)
}
inline ::std::string *Sensor::mutable_min_path() {

  // @@protoc_insertion_point(field_mutable:fc_pb.Sensor.min_path)
  return min_path_.MutableNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string *Sensor::release_min_path() {
  // @@protoc_insertion_point(field_release:fc_pb.Sensor.min_path)

  return min_path_.ReleaseNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sensor::set_allocated_min_path(::std::string *min_path) {
  if (min_path != NULL) {

  } else {
  }
  min_path_.SetAllocatedNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), min_path);
  // @@protoc_insertion_point(field_set_allocated:fc_pb.Sensor.min_path)
}

// string max_path = 14;
inline void Sensor::clear_max_path() {
  max_path_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string &Sensor::max_path() const {
  // @@protoc_insertion_point(field_get:fc_pb.Sensor.max_path)
  return max_path_.GetNoArena();
}
inline void Sensor::set_max_path(const ::std::string &value) {

  max_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fc_pb.Sensor.max_path)
}
#if LANG_CXX11
inline void Sensor::set_max_path(::std::string &&value) {

  max_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fc_pb.Sensor.max_path)
}
#endif
inline void Sensor::set_max_path(const char *value) {
  GOOGLE_DCHECK(value != NULL);

  max_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fc_pb.Sensor.max_path)
}
inline void Sensor::set_max_path(const char *value, size_t size) {

  max_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char *>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fc_pb.Sensor.max_path)
}
inline ::std::string *Sensor::mutable_max_path() {

  // @@protoc_insertion_point(field_mutable:fc_pb.Sensor.max_path)
  return max_path_.MutableNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string *Sensor::release_max_path() {
  // @@protoc_insertion_point(field_release:fc_pb.Sensor.max_path)

  return max_path_.ReleaseNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sensor::set_allocated_max_path(::std::string *max_path) {
  if (max_path != NULL) {

  } else {
  }
  max_path_.SetAllocatedNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), max_path);
  // @@protoc_insertion_point(field_set_allocated:fc_pb.Sensor.max_path)
}

// string crit_path = 15;
inline void Sensor::clear_crit_path() {
  crit_path_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string &Sensor::crit_path() const {
  // @@protoc_insertion_point(field_get:fc_pb.Sensor.crit_path)
  return crit_path_.GetNoArena();
}
inline void Sensor::set_crit_path(const ::std::string &value) {

  crit_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fc_pb.Sensor.crit_path)
}
#if LANG_CXX11
inline void Sensor::set_crit_path(::std::string &&value) {

  crit_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fc_pb.Sensor.crit_path)
}
#endif
inline void Sensor::set_crit_path(const char *value) {
  GOOGLE_DCHECK(value != NULL);

  crit_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fc_pb.Sensor.crit_path)
}
inline void Sensor::set_crit_path(const char *value, size_t size) {

  crit_path_.SetNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char *>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fc_pb.Sensor.crit_path)
}
inline ::std::string *Sensor::mutable_crit_path() {

  // @@protoc_insertion_point(field_mutable:fc_pb.Sensor.crit_path)
  return crit_path_.MutableNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string *Sensor::release_crit_path() {
  // @@protoc_insertion_point(field_release:fc_pb.Sensor.crit_path)

  return crit_path_.ReleaseNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sensor::set_allocated_crit_path(::std::string *crit_path) {
  if (crit_path != NULL) {

  } else {
  }
  crit_path_.SetAllocatedNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited(), crit_path);
  // @@protoc_insertion_point(field_set_allocated:fc_pb.Sensor.crit_path)
}

// int32 id = 20;
inline void Sensor::clear_id() { id_ = 0; }
inline ::google::protobuf::int32 Sensor::id() const {
  // @@protoc_insertion_point(field_get:fc_pb.Sensor.id)
  return id_;
}
inline void Sensor::set_id(::google::protobuf::int32 value) {

  id_ = value;
  // @@protoc_insertion_point(field_set:fc_pb.Sensor.id)
}

// -------------------------------------------------------------------

// DevicesRequest

// bool include_unsupported = 1;
inline void DevicesRequest::clear_include_unsupported() {
  include_unsupported_ = false;
}
inline bool DevicesRequest::include_unsupported() const {
  // @@protoc_insertion_point(field_get:fc_pb.DevicesRequest.include_unsupported)
  return include_unsupported_;
}
inline void DevicesRequest::set_include_unsupported(bool value) {

  include_unsupported_ = value;
  // @@protoc_insertion_point(field_set:fc_pb.DevicesRequest.include_unsupported)
}

// -------------------------------------------------------------------

// ControllerState

// .fc_pb.ControllerState.State state = 1;
inline void ControllerState::clear_state() { state_ = 0; }
inline ::fc_pb::ControllerState_State ControllerState::state() const {
  // @@protoc_insertion_point(field_get:fc_pb.ControllerState.state)
  return static_cast<::fc_pb::ControllerState_State>(state_);
}
inline void ControllerState::set_state(::fc_pb::ControllerState_State value) {

  state_ = value;
  // @@protoc_insertion_point(field_set:fc_pb.ControllerState.state)
}

// -------------------------------------------------------------------

// Empty

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace fc_pb

namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::fc_pb::ControllerState_State> : ::std::true_type {};
template <>
inline const EnumDescriptor *
GetEnumDescriptor<::fc_pb::ControllerState_State>() {
  return ::fc_pb::ControllerState_State_descriptor();
}
template <> struct is_proto_enum<::fc_pb::DevType> : ::std::true_type {};
template <> inline const EnumDescriptor *GetEnumDescriptor<::fc_pb::DevType>() {
  return ::fc_pb::DevType_descriptor();
}

} // namespace protobuf
} // namespace google

// @@protoc_insertion_point(global_scope)

#endif // PROTOBUF_INCLUDED_DevicesSpec_2eproto

#ifdef __clang__
#pragma clang diagnostic pop
#elif __GNUC__
#pragma GCC diagnostic pop
#endif //__clang__
