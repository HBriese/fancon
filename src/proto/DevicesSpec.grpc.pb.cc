// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: DevicesSpec.proto

#include "DevicesSpec.grpc.pb.h"
#include "DevicesSpec.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace fc_pb {

static const char *DService_method_names[] = {
    "/fc_pb.DService/GetControllerState",
    "/fc_pb.DService/SetControllerState",
    "/fc_pb.DService/GetControllerConfig",
    "/fc_pb.DService/SetControllerConfig",
    "/fc_pb.DService/GetDevices",
    "/fc_pb.DService/SetDevices",
};

std::unique_ptr<DService::Stub>
DService::NewStub(const std::shared_ptr<::grpc::ChannelInterface> &channel,
                  const ::grpc::StubOptions &options) {
  (void)options;
  std::unique_ptr<DService::Stub> stub(new DService::Stub(channel));
  return stub;
}

DService::Stub::Stub(const std::shared_ptr<::grpc::ChannelInterface> &channel)
    : channel_(channel),
      rpcmethod_GetControllerState_(DService_method_names[0],
                                    ::grpc::internal::RpcMethod::NORMAL_RPC,
                                    channel),
      rpcmethod_SetControllerState_(DService_method_names[1],
                                    ::grpc::internal::RpcMethod::NORMAL_RPC,
                                    channel),
      rpcmethod_GetControllerConfig_(DService_method_names[2],
                                     ::grpc::internal::RpcMethod::NORMAL_RPC,
                                     channel),
      rpcmethod_SetControllerConfig_(DService_method_names[3],
                                     ::grpc::internal::RpcMethod::NORMAL_RPC,
                                     channel),
      rpcmethod_GetDevices_(DService_method_names[4],
                            ::grpc::internal::RpcMethod::NORMAL_RPC, channel),
      rpcmethod_SetDevices_(DService_method_names[5],
                            ::grpc::internal::RpcMethod::NORMAL_RPC, channel) {}

::grpc::Status
DService::Stub::GetControllerState(::grpc::ClientContext *context,
                                   const ::fc_pb::Empty &request,
                                   ::fc_pb::ControllerState *response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(),
                                             rpcmethod_GetControllerState_,
                                             context, request, response);
}

void DService::Stub::experimental_async::GetControllerState(
    ::grpc::ClientContext *context, const ::fc_pb::Empty *request,
    ::fc_pb::ControllerState *response, std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(
      stub_->channel_.get(), stub_->rpcmethod_GetControllerState_, context,
      request, response, std::move(f));
}

::grpc::ClientAsyncResponseReader<::fc_pb::ControllerState> *
DService::Stub::AsyncGetControllerStateRaw(::grpc::ClientContext *context,
                                           const ::fc_pb::Empty &request,
                                           ::grpc::CompletionQueue *cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory<
      ::fc_pb::ControllerState>::Create(channel_.get(), cq,
                                        rpcmethod_GetControllerState_, context,
                                        request, true);
}

::grpc::ClientAsyncResponseReader<::fc_pb::ControllerState> *
DService::Stub::PrepareAsyncGetControllerStateRaw(
    ::grpc::ClientContext *context, const ::fc_pb::Empty &request,
    ::grpc::CompletionQueue *cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory<
      ::fc_pb::ControllerState>::Create(channel_.get(), cq,
                                        rpcmethod_GetControllerState_, context,
                                        request, false);
}

::grpc::Status
DService::Stub::SetControllerState(::grpc::ClientContext *context,
                                   const ::fc_pb::ControllerState &request,
                                   ::fc_pb::Empty *response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(),
                                             rpcmethod_SetControllerState_,
                                             context, request, response);
}

void DService::Stub::experimental_async::SetControllerState(
    ::grpc::ClientContext *context, const ::fc_pb::ControllerState *request,
    ::fc_pb::Empty *response, std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(
      stub_->channel_.get(), stub_->rpcmethod_SetControllerState_, context,
      request, response, std::move(f));
}

::grpc::ClientAsyncResponseReader<::fc_pb::Empty> *
DService::Stub::AsyncSetControllerStateRaw(
    ::grpc::ClientContext *context, const ::fc_pb::ControllerState &request,
    ::grpc::CompletionQueue *cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory<
      ::fc_pb::Empty>::Create(channel_.get(), cq, rpcmethod_SetControllerState_,
                              context, request, true);
}

::grpc::ClientAsyncResponseReader<::fc_pb::Empty> *
DService::Stub::PrepareAsyncSetControllerStateRaw(
    ::grpc::ClientContext *context, const ::fc_pb::ControllerState &request,
    ::grpc::CompletionQueue *cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory<
      ::fc_pb::Empty>::Create(channel_.get(), cq, rpcmethod_SetControllerState_,
                              context, request, false);
}

::grpc::Status
DService::Stub::GetControllerConfig(::grpc::ClientContext *context,
                                    const ::fc_pb::Empty &request,
                                    ::fc_pb::ControllerConfig *response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(),
                                             rpcmethod_GetControllerConfig_,
                                             context, request, response);
}

void DService::Stub::experimental_async::GetControllerConfig(
    ::grpc::ClientContext *context, const ::fc_pb::Empty *request,
    ::fc_pb::ControllerConfig *response,
    std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(
      stub_->channel_.get(), stub_->rpcmethod_GetControllerConfig_, context,
      request, response, std::move(f));
}

::grpc::ClientAsyncResponseReader<::fc_pb::ControllerConfig> *
DService::Stub::AsyncGetControllerConfigRaw(::grpc::ClientContext *context,
                                            const ::fc_pb::Empty &request,
                                            ::grpc::CompletionQueue *cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory<
      ::fc_pb::ControllerConfig>::Create(channel_.get(), cq,
                                         rpcmethod_GetControllerConfig_,
                                         context, request, true);
}

::grpc::ClientAsyncResponseReader<::fc_pb::ControllerConfig> *
DService::Stub::PrepareAsyncGetControllerConfigRaw(
    ::grpc::ClientContext *context, const ::fc_pb::Empty &request,
    ::grpc::CompletionQueue *cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory<
      ::fc_pb::ControllerConfig>::Create(channel_.get(), cq,
                                         rpcmethod_GetControllerConfig_,
                                         context, request, false);
}

::grpc::Status
DService::Stub::SetControllerConfig(::grpc::ClientContext *context,
                                    const ::fc_pb::ControllerConfig &request,
                                    ::fc_pb::Empty *response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(),
                                             rpcmethod_SetControllerConfig_,
                                             context, request, response);
}

void DService::Stub::experimental_async::SetControllerConfig(
    ::grpc::ClientContext *context, const ::fc_pb::ControllerConfig *request,
    ::fc_pb::Empty *response, std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(
      stub_->channel_.get(), stub_->rpcmethod_SetControllerConfig_, context,
      request, response, std::move(f));
}

::grpc::ClientAsyncResponseReader<::fc_pb::Empty> *
DService::Stub::AsyncSetControllerConfigRaw(
    ::grpc::ClientContext *context, const ::fc_pb::ControllerConfig &request,
    ::grpc::CompletionQueue *cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory<
      ::fc_pb::Empty>::Create(channel_.get(), cq,
                              rpcmethod_SetControllerConfig_, context, request,
                              true);
}

::grpc::ClientAsyncResponseReader<::fc_pb::Empty> *
DService::Stub::PrepareAsyncSetControllerConfigRaw(
    ::grpc::ClientContext *context, const ::fc_pb::ControllerConfig &request,
    ::grpc::CompletionQueue *cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory<
      ::fc_pb::Empty>::Create(channel_.get(), cq,
                              rpcmethod_SetControllerConfig_, context, request,
                              false);
}

::grpc::Status
DService::Stub::GetDevices(::grpc::ClientContext *context,
                           const ::fc_pb::DevicesRequest &request,
                           ::fc_pb::Devices *response) {
  return ::grpc::internal::BlockingUnaryCall(
      channel_.get(), rpcmethod_GetDevices_, context, request, response);
}

void DService::Stub::experimental_async::GetDevices(
    ::grpc::ClientContext *context, const ::fc_pb::DevicesRequest *request,
    ::fc_pb::Devices *response, std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(
      stub_->channel_.get(), stub_->rpcmethod_GetDevices_, context, request,
      response, std::move(f));
}

::grpc::ClientAsyncResponseReader<::fc_pb::Devices> *
DService::Stub::AsyncGetDevicesRaw(::grpc::ClientContext *context,
                                   const ::fc_pb::DevicesRequest &request,
                                   ::grpc::CompletionQueue *cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory<
      ::fc_pb::Devices>::Create(channel_.get(), cq, rpcmethod_GetDevices_,
                                context, request, true);
}

::grpc::ClientAsyncResponseReader<::fc_pb::Devices> *
DService::Stub::PrepareAsyncGetDevicesRaw(
    ::grpc::ClientContext *context, const ::fc_pb::DevicesRequest &request,
    ::grpc::CompletionQueue *cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory<
      ::fc_pb::Devices>::Create(channel_.get(), cq, rpcmethod_GetDevices_,
                                context, request, false);
}

::grpc::Status DService::Stub::SetDevices(::grpc::ClientContext *context,
                                          const ::fc_pb::Devices &request,
                                          ::fc_pb::Empty *response) {
  return ::grpc::internal::BlockingUnaryCall(
      channel_.get(), rpcmethod_SetDevices_, context, request, response);
}

void DService::Stub::experimental_async::SetDevices(
    ::grpc::ClientContext *context, const ::fc_pb::Devices *request,
    ::fc_pb::Empty *response, std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(
      stub_->channel_.get(), stub_->rpcmethod_SetDevices_, context, request,
      response, std::move(f));
}

::grpc::ClientAsyncResponseReader<::fc_pb::Empty> *
DService::Stub::AsyncSetDevicesRaw(::grpc::ClientContext *context,
                                   const ::fc_pb::Devices &request,
                                   ::grpc::CompletionQueue *cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory<
      ::fc_pb::Empty>::Create(channel_.get(), cq, rpcmethod_SetDevices_,
                              context, request, true);
}

::grpc::ClientAsyncResponseReader<::fc_pb::Empty> *
DService::Stub::PrepareAsyncSetDevicesRaw(::grpc::ClientContext *context,
                                          const ::fc_pb::Devices &request,
                                          ::grpc::CompletionQueue *cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory<
      ::fc_pb::Empty>::Create(channel_.get(), cq, rpcmethod_SetDevices_,
                              context, request, false);
}

DService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DService_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler<DService::Service, ::fc_pb::Empty,
                                             ::fc_pb::ControllerState>(
          std::mem_fn(&DService::Service::GetControllerState), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DService_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler<
          DService::Service, ::fc_pb::ControllerState, ::fc_pb::Empty>(
          std::mem_fn(&DService::Service::SetControllerState), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DService_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler<DService::Service, ::fc_pb::Empty,
                                             ::fc_pb::ControllerConfig>(
          std::mem_fn(&DService::Service::GetControllerConfig), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DService_method_names[3], ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler<
          DService::Service, ::fc_pb::ControllerConfig, ::fc_pb::Empty>(
          std::mem_fn(&DService::Service::SetControllerConfig), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DService_method_names[4], ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler<
          DService::Service, ::fc_pb::DevicesRequest, ::fc_pb::Devices>(
          std::mem_fn(&DService::Service::GetDevices), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DService_method_names[5], ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler<DService::Service,
                                             ::fc_pb::Devices, ::fc_pb::Empty>(
          std::mem_fn(&DService::Service::SetDevices), this)));
}

DService::Service::~Service() {}

::grpc::Status
DService::Service::GetControllerState(::grpc::ServerContext *context,
                                      const ::fc_pb::Empty *request,
                                      ::fc_pb::ControllerState *response) {
  (void)context;
  (void)request;
  (void)response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status
DService::Service::SetControllerState(::grpc::ServerContext *context,
                                      const ::fc_pb::ControllerState *request,
                                      ::fc_pb::Empty *response) {
  (void)context;
  (void)request;
  (void)response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status
DService::Service::GetControllerConfig(::grpc::ServerContext *context,
                                       const ::fc_pb::Empty *request,
                                       ::fc_pb::ControllerConfig *response) {
  (void)context;
  (void)request;
  (void)response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status
DService::Service::SetControllerConfig(::grpc::ServerContext *context,
                                       const ::fc_pb::ControllerConfig *request,
                                       ::fc_pb::Empty *response) {
  (void)context;
  (void)request;
  (void)response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status
DService::Service::GetDevices(::grpc::ServerContext *context,
                              const ::fc_pb::DevicesRequest *request,
                              ::fc_pb::Devices *response) {
  (void)context;
  (void)request;
  (void)response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DService::Service::SetDevices(::grpc::ServerContext *context,
                                             const ::fc_pb::Devices *request,
                                             ::fc_pb::Empty *response) {
  (void)context;
  (void)request;
  (void)response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

} // namespace fc_pb
