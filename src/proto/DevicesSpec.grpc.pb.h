#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
#elif __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
#endif //__clang__

// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: DevicesSpec.proto
#ifndef GRPC_DevicesSpec_2eproto__INCLUDED
#define GRPC_DevicesSpec_2eproto__INCLUDED

#include "DevicesSpec.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc {
class CompletionQueue;
class Channel;
class ServerCompletionQueue;
class ServerContext;
} // namespace grpc

namespace fc_pb {

class DService final {
public:
  static constexpr char const *service_full_name() { return "fc_pb.DService"; }
  class StubInterface {
  public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status
    GetControllerState(::grpc::ClientContext *context,
                       const ::fc_pb::Empty &request,
                       ::fc_pb::ControllerState *response) = 0;
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::fc_pb::ControllerState>>
    AsyncGetControllerState(::grpc::ClientContext *context,
                            const ::fc_pb::Empty &request,
                            ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReaderInterface<::fc_pb::ControllerState>>(
          AsyncGetControllerStateRaw(context, request, cq));
    }
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::fc_pb::ControllerState>>
    PrepareAsyncGetControllerState(::grpc::ClientContext *context,
                                   const ::fc_pb::Empty &request,
                                   ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReaderInterface<::fc_pb::ControllerState>>(
          PrepareAsyncGetControllerStateRaw(context, request, cq));
    }
    virtual ::grpc::Status
    SetControllerState(::grpc::ClientContext *context,
                       const ::fc_pb::ControllerState &request,
                       ::fc_pb::Empty *response) = 0;
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::fc_pb::Empty>>
    AsyncSetControllerState(::grpc::ClientContext *context,
                            const ::fc_pb::ControllerState &request,
                            ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReaderInterface<::fc_pb::Empty>>(
          AsyncSetControllerStateRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::fc_pb::Empty>>
    PrepareAsyncSetControllerState(::grpc::ClientContext *context,
                                   const ::fc_pb::ControllerState &request,
                                   ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReaderInterface<::fc_pb::Empty>>(
          PrepareAsyncSetControllerStateRaw(context, request, cq));
    }
    virtual ::grpc::Status
    GetControllerConfig(::grpc::ClientContext *context,
                        const ::fc_pb::Empty &request,
                        ::fc_pb::ControllerConfig *response) = 0;
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::fc_pb::ControllerConfig>>
    AsyncGetControllerConfig(::grpc::ClientContext *context,
                             const ::fc_pb::Empty &request,
                             ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
          ::fc_pb::ControllerConfig>>(
          AsyncGetControllerConfigRaw(context, request, cq));
    }
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::fc_pb::ControllerConfig>>
    PrepareAsyncGetControllerConfig(::grpc::ClientContext *context,
                                    const ::fc_pb::Empty &request,
                                    ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
          ::fc_pb::ControllerConfig>>(
          PrepareAsyncGetControllerConfigRaw(context, request, cq));
    }
    virtual ::grpc::Status
    SetControllerConfig(::grpc::ClientContext *context,
                        const ::fc_pb::ControllerConfig &request,
                        ::fc_pb::Empty *response) = 0;
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::fc_pb::Empty>>
    AsyncSetControllerConfig(::grpc::ClientContext *context,
                             const ::fc_pb::ControllerConfig &request,
                             ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReaderInterface<::fc_pb::Empty>>(
          AsyncSetControllerConfigRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::fc_pb::Empty>>
    PrepareAsyncSetControllerConfig(::grpc::ClientContext *context,
                                    const ::fc_pb::ControllerConfig &request,
                                    ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReaderInterface<::fc_pb::Empty>>(
          PrepareAsyncSetControllerConfigRaw(context, request, cq));
    }
    virtual ::grpc::Status GetDevices(::grpc::ClientContext *context,
                                      const ::fc_pb::DevicesRequest &request,
                                      ::fc_pb::Devices *response) = 0;
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::fc_pb::Devices>>
    AsyncGetDevices(::grpc::ClientContext *context,
                    const ::fc_pb::DevicesRequest &request,
                    ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReaderInterface<::fc_pb::Devices>>(
          AsyncGetDevicesRaw(context, request, cq));
    }
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::fc_pb::Devices>>
    PrepareAsyncGetDevices(::grpc::ClientContext *context,
                           const ::fc_pb::DevicesRequest &request,
                           ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReaderInterface<::fc_pb::Devices>>(
          PrepareAsyncGetDevicesRaw(context, request, cq));
    }
    virtual ::grpc::Status SetDevices(::grpc::ClientContext *context,
                                      const ::fc_pb::Devices &request,
                                      ::fc_pb::Empty *response) = 0;
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::fc_pb::Empty>>
    AsyncSetDevices(::grpc::ClientContext *context,
                    const ::fc_pb::Devices &request,
                    ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReaderInterface<::fc_pb::Empty>>(
          AsyncSetDevicesRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::fc_pb::Empty>>
    PrepareAsyncSetDevices(::grpc::ClientContext *context,
                           const ::fc_pb::Devices &request,
                           ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReaderInterface<::fc_pb::Empty>>(
          PrepareAsyncSetDevicesRaw(context, request, cq));
    }
    class experimental_async_interface {
    public:
      virtual ~experimental_async_interface() {}
      virtual void GetControllerState(::grpc::ClientContext *context,
                                      const ::fc_pb::Empty *request,
                                      ::fc_pb::ControllerState *response,
                                      std::function<void(::grpc::Status)>) = 0;
      virtual void SetControllerState(::grpc::ClientContext *context,
                                      const ::fc_pb::ControllerState *request,
                                      ::fc_pb::Empty *response,
                                      std::function<void(::grpc::Status)>) = 0;
      virtual void GetControllerConfig(::grpc::ClientContext *context,
                                       const ::fc_pb::Empty *request,
                                       ::fc_pb::ControllerConfig *response,
                                       std::function<void(::grpc::Status)>) = 0;
      virtual void SetControllerConfig(::grpc::ClientContext *context,
                                       const ::fc_pb::ControllerConfig *request,
                                       ::fc_pb::Empty *response,
                                       std::function<void(::grpc::Status)>) = 0;
      virtual void GetDevices(::grpc::ClientContext *context,
                              const ::fc_pb::DevicesRequest *request,
                              ::fc_pb::Devices *response,
                              std::function<void(::grpc::Status)>) = 0;
      virtual void SetDevices(::grpc::ClientContext *context,
                              const ::fc_pb::Devices *request,
                              ::fc_pb::Empty *response,
                              std::function<void(::grpc::Status)>) = 0;
    };
    virtual class experimental_async_interface *experimental_async() {
      return nullptr;
    }

  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface<::fc_pb::ControllerState>
        *AsyncGetControllerStateRaw(::grpc::ClientContext *context,
                                    const ::fc_pb::Empty &request,
                                    ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::fc_pb::ControllerState>
        *PrepareAsyncGetControllerStateRaw(::grpc::ClientContext *context,
                                           const ::fc_pb::Empty &request,
                                           ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::fc_pb::Empty> *
    AsyncSetControllerStateRaw(::grpc::ClientContext *context,
                               const ::fc_pb::ControllerState &request,
                               ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::fc_pb::Empty> *
    PrepareAsyncSetControllerStateRaw(::grpc::ClientContext *context,
                                      const ::fc_pb::ControllerState &request,
                                      ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<
        ::fc_pb::ControllerConfig> *
    AsyncGetControllerConfigRaw(::grpc::ClientContext *context,
                                const ::fc_pb::Empty &request,
                                ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<
        ::fc_pb::ControllerConfig> *
    PrepareAsyncGetControllerConfigRaw(::grpc::ClientContext *context,
                                       const ::fc_pb::Empty &request,
                                       ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::fc_pb::Empty> *
    AsyncSetControllerConfigRaw(::grpc::ClientContext *context,
                                const ::fc_pb::ControllerConfig &request,
                                ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::fc_pb::Empty> *
    PrepareAsyncSetControllerConfigRaw(::grpc::ClientContext *context,
                                       const ::fc_pb::ControllerConfig &request,
                                       ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::fc_pb::Devices> *
    AsyncGetDevicesRaw(::grpc::ClientContext *context,
                       const ::fc_pb::DevicesRequest &request,
                       ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::fc_pb::Devices> *
    PrepareAsyncGetDevicesRaw(::grpc::ClientContext *context,
                              const ::fc_pb::DevicesRequest &request,
                              ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::fc_pb::Empty> *
    AsyncSetDevicesRaw(::grpc::ClientContext *context,
                       const ::fc_pb::Devices &request,
                       ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::fc_pb::Empty> *
    PrepareAsyncSetDevicesRaw(::grpc::ClientContext *context,
                              const ::fc_pb::Devices &request,
                              ::grpc::CompletionQueue *cq) = 0;
  };
  class Stub final : public StubInterface {
  public:
    Stub(const std::shared_ptr<::grpc::ChannelInterface> &channel);
    ::grpc::Status
    GetControllerState(::grpc::ClientContext *context,
                       const ::fc_pb::Empty &request,
                       ::fc_pb::ControllerState *response) override;
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::fc_pb::ControllerState>>
    AsyncGetControllerState(::grpc::ClientContext *context,
                            const ::fc_pb::Empty &request,
                            ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::fc_pb::ControllerState>>(
          AsyncGetControllerStateRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::fc_pb::ControllerState>>
    PrepareAsyncGetControllerState(::grpc::ClientContext *context,
                                   const ::fc_pb::Empty &request,
                                   ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::fc_pb::ControllerState>>(
          PrepareAsyncGetControllerStateRaw(context, request, cq));
    }
    ::grpc::Status SetControllerState(::grpc::ClientContext *context,
                                      const ::fc_pb::ControllerState &request,
                                      ::fc_pb::Empty *response) override;
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::fc_pb::Empty>>
    AsyncSetControllerState(::grpc::ClientContext *context,
                            const ::fc_pb::ControllerState &request,
                            ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReader<::fc_pb::Empty>>(
          AsyncSetControllerStateRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::fc_pb::Empty>>
    PrepareAsyncSetControllerState(::grpc::ClientContext *context,
                                   const ::fc_pb::ControllerState &request,
                                   ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReader<::fc_pb::Empty>>(
          PrepareAsyncSetControllerStateRaw(context, request, cq));
    }
    ::grpc::Status
    GetControllerConfig(::grpc::ClientContext *context,
                        const ::fc_pb::Empty &request,
                        ::fc_pb::ControllerConfig *response) override;
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReader<::fc_pb::ControllerConfig>>
    AsyncGetControllerConfig(::grpc::ClientContext *context,
                             const ::fc_pb::Empty &request,
                             ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::fc_pb::ControllerConfig>>(
          AsyncGetControllerConfigRaw(context, request, cq));
    }
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReader<::fc_pb::ControllerConfig>>
    PrepareAsyncGetControllerConfig(::grpc::ClientContext *context,
                                    const ::fc_pb::Empty &request,
                                    ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::fc_pb::ControllerConfig>>(
          PrepareAsyncGetControllerConfigRaw(context, request, cq));
    }
    ::grpc::Status SetControllerConfig(::grpc::ClientContext *context,
                                       const ::fc_pb::ControllerConfig &request,
                                       ::fc_pb::Empty *response) override;
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::fc_pb::Empty>>
    AsyncSetControllerConfig(::grpc::ClientContext *context,
                             const ::fc_pb::ControllerConfig &request,
                             ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReader<::fc_pb::Empty>>(
          AsyncSetControllerConfigRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::fc_pb::Empty>>
    PrepareAsyncSetControllerConfig(::grpc::ClientContext *context,
                                    const ::fc_pb::ControllerConfig &request,
                                    ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReader<::fc_pb::Empty>>(
          PrepareAsyncSetControllerConfigRaw(context, request, cq));
    }
    ::grpc::Status GetDevices(::grpc::ClientContext *context,
                              const ::fc_pb::DevicesRequest &request,
                              ::fc_pb::Devices *response) override;
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::fc_pb::Devices>>
    AsyncGetDevices(::grpc::ClientContext *context,
                    const ::fc_pb::DevicesRequest &request,
                    ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::fc_pb::Devices>>(
          AsyncGetDevicesRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::fc_pb::Devices>>
    PrepareAsyncGetDevices(::grpc::ClientContext *context,
                           const ::fc_pb::DevicesRequest &request,
                           ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::fc_pb::Devices>>(
          PrepareAsyncGetDevicesRaw(context, request, cq));
    }
    ::grpc::Status SetDevices(::grpc::ClientContext *context,
                              const ::fc_pb::Devices &request,
                              ::fc_pb::Empty *response) override;
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::fc_pb::Empty>>
    AsyncSetDevices(::grpc::ClientContext *context,
                    const ::fc_pb::Devices &request,
                    ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReader<::fc_pb::Empty>>(
          AsyncSetDevicesRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::fc_pb::Empty>>
    PrepareAsyncSetDevices(::grpc::ClientContext *context,
                           const ::fc_pb::Devices &request,
                           ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReader<::fc_pb::Empty>>(
          PrepareAsyncSetDevicesRaw(context, request, cq));
    }
    class experimental_async final
        : public StubInterface::experimental_async_interface {
    public:
      void GetControllerState(::grpc::ClientContext *context,
                              const ::fc_pb::Empty *request,
                              ::fc_pb::ControllerState *response,
                              std::function<void(::grpc::Status)>) override;
      void SetControllerState(::grpc::ClientContext *context,
                              const ::fc_pb::ControllerState *request,
                              ::fc_pb::Empty *response,
                              std::function<void(::grpc::Status)>) override;
      void GetControllerConfig(::grpc::ClientContext *context,
                               const ::fc_pb::Empty *request,
                               ::fc_pb::ControllerConfig *response,
                               std::function<void(::grpc::Status)>) override;
      void SetControllerConfig(::grpc::ClientContext *context,
                               const ::fc_pb::ControllerConfig *request,
                               ::fc_pb::Empty *response,
                               std::function<void(::grpc::Status)>) override;
      void GetDevices(::grpc::ClientContext *context,
                      const ::fc_pb::DevicesRequest *request,
                      ::fc_pb::Devices *response,
                      std::function<void(::grpc::Status)>) override;
      void SetDevices(::grpc::ClientContext *context,
                      const ::fc_pb::Devices *request, ::fc_pb::Empty *response,
                      std::function<void(::grpc::Status)>) override;

    private:
      friend class Stub;
      explicit experimental_async(Stub *stub) : stub_(stub) {}
      Stub *stub() { return stub_; }
      Stub *stub_;
    };
    class experimental_async_interface *experimental_async() override {
      return &async_stub_;
    }

  private:
    std::shared_ptr<::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_ {
      this
    };
    ::grpc::ClientAsyncResponseReader<::fc_pb::ControllerState> *
    AsyncGetControllerStateRaw(::grpc::ClientContext *context,
                               const ::fc_pb::Empty &request,
                               ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::fc_pb::ControllerState> *
    PrepareAsyncGetControllerStateRaw(::grpc::ClientContext *context,
                                      const ::fc_pb::Empty &request,
                                      ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::fc_pb::Empty> *
    AsyncSetControllerStateRaw(::grpc::ClientContext *context,
                               const ::fc_pb::ControllerState &request,
                               ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::fc_pb::Empty> *
    PrepareAsyncSetControllerStateRaw(::grpc::ClientContext *context,
                                      const ::fc_pb::ControllerState &request,
                                      ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::fc_pb::ControllerConfig> *
    AsyncGetControllerConfigRaw(::grpc::ClientContext *context,
                                const ::fc_pb::Empty &request,
                                ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::fc_pb::ControllerConfig> *
    PrepareAsyncGetControllerConfigRaw(::grpc::ClientContext *context,
                                       const ::fc_pb::Empty &request,
                                       ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::fc_pb::Empty> *
    AsyncSetControllerConfigRaw(::grpc::ClientContext *context,
                                const ::fc_pb::ControllerConfig &request,
                                ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::fc_pb::Empty> *
    PrepareAsyncSetControllerConfigRaw(::grpc::ClientContext *context,
                                       const ::fc_pb::ControllerConfig &request,
                                       ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::fc_pb::Devices> *
    AsyncGetDevicesRaw(::grpc::ClientContext *context,
                       const ::fc_pb::DevicesRequest &request,
                       ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::fc_pb::Devices> *
    PrepareAsyncGetDevicesRaw(::grpc::ClientContext *context,
                              const ::fc_pb::DevicesRequest &request,
                              ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::fc_pb::Empty> *
    AsyncSetDevicesRaw(::grpc::ClientContext *context,
                       const ::fc_pb::Devices &request,
                       ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::fc_pb::Empty> *
    PrepareAsyncSetDevicesRaw(::grpc::ClientContext *context,
                              const ::fc_pb::Devices &request,
                              ::grpc::CompletionQueue *cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetControllerState_;
    const ::grpc::internal::RpcMethod rpcmethod_SetControllerState_;
    const ::grpc::internal::RpcMethod rpcmethod_GetControllerConfig_;
    const ::grpc::internal::RpcMethod rpcmethod_SetControllerConfig_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDevices_;
    const ::grpc::internal::RpcMethod rpcmethod_SetDevices_;
  };
  static std::unique_ptr<Stub>
  NewStub(const std::shared_ptr<::grpc::ChannelInterface> &channel,
          const ::grpc::StubOptions &options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
  public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status
    GetControllerState(::grpc::ServerContext *context,
                       const ::fc_pb::Empty *request,
                       ::fc_pb::ControllerState *response);
    virtual ::grpc::Status
    SetControllerState(::grpc::ServerContext *context,
                       const ::fc_pb::ControllerState *request,
                       ::fc_pb::Empty *response);
    virtual ::grpc::Status
    GetControllerConfig(::grpc::ServerContext *context,
                        const ::fc_pb::Empty *request,
                        ::fc_pb::ControllerConfig *response);
    virtual ::grpc::Status
    SetControllerConfig(::grpc::ServerContext *context,
                        const ::fc_pb::ControllerConfig *request,
                        ::fc_pb::Empty *response);
    virtual ::grpc::Status GetDevices(::grpc::ServerContext *context,
                                      const ::fc_pb::DevicesRequest *request,
                                      ::fc_pb::Devices *response);
    virtual ::grpc::Status SetDevices(::grpc::ServerContext *context,
                                      const ::fc_pb::Devices *request,
                                      ::fc_pb::Empty *response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetControllerState : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}

  public:
    WithAsyncMethod_GetControllerState() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetControllerState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    GetControllerState(::grpc::ServerContext *context,
                       const ::fc_pb::Empty *request,
                       ::fc_pb::ControllerState *response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetControllerState(
        ::grpc::ServerContext *context, ::fc_pb::Empty *request,
        ::grpc::ServerAsyncResponseWriter<::fc_pb::ControllerState> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetControllerState : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}

  public:
    WithAsyncMethod_SetControllerState() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_SetControllerState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetControllerState(::grpc::ServerContext *context,
                                      const ::fc_pb::ControllerState *request,
                                      ::fc_pb::Empty *response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetControllerState(
        ::grpc::ServerContext *context, ::fc_pb::ControllerState *request,
        ::grpc::ServerAsyncResponseWriter<::fc_pb::Empty> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetControllerConfig : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}

  public:
    WithAsyncMethod_GetControllerConfig() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetControllerConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    GetControllerConfig(::grpc::ServerContext *context,
                        const ::fc_pb::Empty *request,
                        ::fc_pb::ControllerConfig *response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetControllerConfig(
        ::grpc::ServerContext *context, ::fc_pb::Empty *request,
        ::grpc::ServerAsyncResponseWriter<::fc_pb::ControllerConfig> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetControllerConfig : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}

  public:
    WithAsyncMethod_SetControllerConfig() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_SetControllerConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetControllerConfig(::grpc::ServerContext *context,
                                       const ::fc_pb::ControllerConfig *request,
                                       ::fc_pb::Empty *response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetControllerConfig(
        ::grpc::ServerContext *context, ::fc_pb::ControllerConfig *request,
        ::grpc::ServerAsyncResponseWriter<::fc_pb::Empty> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDevices : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}

  public:
    WithAsyncMethod_GetDevices() { ::grpc::Service::MarkMethodAsync(4); }
    ~WithAsyncMethod_GetDevices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDevices(::grpc::ServerContext *context,
                              const ::fc_pb::DevicesRequest *request,
                              ::fc_pb::Devices *response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDevices(
        ::grpc::ServerContext *context, ::fc_pb::DevicesRequest *request,
        ::grpc::ServerAsyncResponseWriter<::fc_pb::Devices> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetDevices : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}

  public:
    WithAsyncMethod_SetDevices() { ::grpc::Service::MarkMethodAsync(5); }
    ~WithAsyncMethod_SetDevices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDevices(::grpc::ServerContext *context,
                              const ::fc_pb::Devices *request,
                              ::fc_pb::Empty *response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDevices(
        ::grpc::ServerContext *context, ::fc_pb::Devices *request,
        ::grpc::ServerAsyncResponseWriter<::fc_pb::Empty> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetControllerState<WithAsyncMethod_SetControllerState<
      WithAsyncMethod_GetControllerConfig<WithAsyncMethod_SetControllerConfig<
          WithAsyncMethod_GetDevices<WithAsyncMethod_SetDevices<Service>>>>>>
      AsyncService;
  template <class BaseClass>
  class WithGenericMethod_GetControllerState : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}

  public:
    WithGenericMethod_GetControllerState() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetControllerState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    GetControllerState(::grpc::ServerContext *context,
                       const ::fc_pb::Empty *request,
                       ::fc_pb::ControllerState *response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetControllerState : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}

  public:
    WithGenericMethod_SetControllerState() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_SetControllerState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetControllerState(::grpc::ServerContext *context,
                                      const ::fc_pb::ControllerState *request,
                                      ::fc_pb::Empty *response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetControllerConfig : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}

  public:
    WithGenericMethod_GetControllerConfig() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetControllerConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    GetControllerConfig(::grpc::ServerContext *context,
                        const ::fc_pb::Empty *request,
                        ::fc_pb::ControllerConfig *response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetControllerConfig : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}

  public:
    WithGenericMethod_SetControllerConfig() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_SetControllerConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetControllerConfig(::grpc::ServerContext *context,
                                       const ::fc_pb::ControllerConfig *request,
                                       ::fc_pb::Empty *response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDevices : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}

  public:
    WithGenericMethod_GetDevices() { ::grpc::Service::MarkMethodGeneric(4); }
    ~WithGenericMethod_GetDevices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDevices(::grpc::ServerContext *context,
                              const ::fc_pb::DevicesRequest *request,
                              ::fc_pb::Devices *response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetDevices : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}

  public:
    WithGenericMethod_SetDevices() { ::grpc::Service::MarkMethodGeneric(5); }
    ~WithGenericMethod_SetDevices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDevices(::grpc::ServerContext *context,
                              const ::fc_pb::Devices *request,
                              ::fc_pb::Empty *response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetControllerState : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}

  public:
    WithRawMethod_GetControllerState() { ::grpc::Service::MarkMethodRaw(0); }
    ~WithRawMethod_GetControllerState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    GetControllerState(::grpc::ServerContext *context,
                       const ::fc_pb::Empty *request,
                       ::fc_pb::ControllerState *response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetControllerState(
        ::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
        ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetControllerState : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}

  public:
    WithRawMethod_SetControllerState() { ::grpc::Service::MarkMethodRaw(1); }
    ~WithRawMethod_SetControllerState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetControllerState(::grpc::ServerContext *context,
                                      const ::fc_pb::ControllerState *request,
                                      ::fc_pb::Empty *response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetControllerState(
        ::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
        ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetControllerConfig : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}

  public:
    WithRawMethod_GetControllerConfig() { ::grpc::Service::MarkMethodRaw(2); }
    ~WithRawMethod_GetControllerConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    GetControllerConfig(::grpc::ServerContext *context,
                        const ::fc_pb::Empty *request,
                        ::fc_pb::ControllerConfig *response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetControllerConfig(
        ::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
        ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetControllerConfig : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}

  public:
    WithRawMethod_SetControllerConfig() { ::grpc::Service::MarkMethodRaw(3); }
    ~WithRawMethod_SetControllerConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetControllerConfig(::grpc::ServerContext *context,
                                       const ::fc_pb::ControllerConfig *request,
                                       ::fc_pb::Empty *response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetControllerConfig(
        ::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
        ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass> class WithRawMethod_GetDevices : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}

  public:
    WithRawMethod_GetDevices() { ::grpc::Service::MarkMethodRaw(4); }
    ~WithRawMethod_GetDevices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDevices(::grpc::ServerContext *context,
                              const ::fc_pb::DevicesRequest *request,
                              ::fc_pb::Devices *response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDevices(
        ::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
        ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass> class WithRawMethod_SetDevices : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}

  public:
    WithRawMethod_SetDevices() { ::grpc::Service::MarkMethodRaw(5); }
    ~WithRawMethod_SetDevices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetDevices(::grpc::ServerContext *context,
                              const ::fc_pb::Devices *request,
                              ::fc_pb::Empty *response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetDevices(
        ::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
        ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetControllerState : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}

  public:
    WithStreamedUnaryMethod_GetControllerState() {
      ::grpc::Service::MarkMethodStreamed(
          0,
          new ::grpc::internal::StreamedUnaryHandler<::fc_pb::Empty,
                                                     ::fc_pb::ControllerState>(
              std::bind(&WithStreamedUnaryMethod_GetControllerState<
                            BaseClass>::StreamedGetControllerState,
                        this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetControllerState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status
    GetControllerState(::grpc::ServerContext *context,
                       const ::fc_pb::Empty *request,
                       ::fc_pb::ControllerState *response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetControllerState(
        ::grpc::ServerContext *context,
        ::grpc::ServerUnaryStreamer<::fc_pb::Empty, ::fc_pb::ControllerState>
            *server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetControllerState : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}

  public:
    WithStreamedUnaryMethod_SetControllerState() {
      ::grpc::Service::MarkMethodStreamed(
          1,
          new ::grpc::internal::StreamedUnaryHandler<::fc_pb::ControllerState,
                                                     ::fc_pb::Empty>(
              std::bind(&WithStreamedUnaryMethod_SetControllerState<
                            BaseClass>::StreamedSetControllerState,
                        this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetControllerState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetControllerState(::grpc::ServerContext *context,
                                      const ::fc_pb::ControllerState *request,
                                      ::fc_pb::Empty *response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetControllerState(
        ::grpc::ServerContext *context,
        ::grpc::ServerUnaryStreamer<::fc_pb::ControllerState, ::fc_pb::Empty>
            *server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetControllerConfig : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}

  public:
    WithStreamedUnaryMethod_GetControllerConfig() {
      ::grpc::Service::MarkMethodStreamed(
          2,
          new ::grpc::internal::StreamedUnaryHandler<::fc_pb::Empty,
                                                     ::fc_pb::ControllerConfig>(
              std::bind(&WithStreamedUnaryMethod_GetControllerConfig<
                            BaseClass>::StreamedGetControllerConfig,
                        this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetControllerConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status
    GetControllerConfig(::grpc::ServerContext *context,
                        const ::fc_pb::Empty *request,
                        ::fc_pb::ControllerConfig *response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetControllerConfig(
        ::grpc::ServerContext *context,
        ::grpc::ServerUnaryStreamer<::fc_pb::Empty, ::fc_pb::ControllerConfig>
            *server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetControllerConfig : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}

  public:
    WithStreamedUnaryMethod_SetControllerConfig() {
      ::grpc::Service::MarkMethodStreamed(
          3,
          new ::grpc::internal::StreamedUnaryHandler<::fc_pb::ControllerConfig,
                                                     ::fc_pb::Empty>(
              std::bind(&WithStreamedUnaryMethod_SetControllerConfig<
                            BaseClass>::StreamedSetControllerConfig,
                        this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetControllerConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetControllerConfig(::grpc::ServerContext *context,
                                       const ::fc_pb::ControllerConfig *request,
                                       ::fc_pb::Empty *response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetControllerConfig(
        ::grpc::ServerContext *context,
        ::grpc::ServerUnaryStreamer<::fc_pb::ControllerConfig, ::fc_pb::Empty>
            *server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDevices : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}

  public:
    WithStreamedUnaryMethod_GetDevices() {
      ::grpc::Service::MarkMethodStreamed(
          4,
          new ::grpc::internal::StreamedUnaryHandler<::fc_pb::DevicesRequest,
                                                     ::fc_pb::Devices>(
              std::bind(&WithStreamedUnaryMethod_GetDevices<
                            BaseClass>::StreamedGetDevices,
                        this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetDevices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDevices(::grpc::ServerContext *context,
                              const ::fc_pb::DevicesRequest *request,
                              ::fc_pb::Devices *response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDevices(
        ::grpc::ServerContext *context,
        ::grpc::ServerUnaryStreamer<::fc_pb::DevicesRequest, ::fc_pb::Devices>
            *server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetDevices : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}

  public:
    WithStreamedUnaryMethod_SetDevices() {
      ::grpc::Service::MarkMethodStreamed(
          5,
          new ::grpc::internal::StreamedUnaryHandler<::fc_pb::Devices,
                                                     ::fc_pb::Empty>(
              std::bind(&WithStreamedUnaryMethod_SetDevices<
                            BaseClass>::StreamedSetDevices,
                        this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetDevices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetDevices(::grpc::ServerContext *context,
                              const ::fc_pb::Devices *request,
                              ::fc_pb::Empty *response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetDevices(
        ::grpc::ServerContext *context,
        ::grpc::ServerUnaryStreamer<::fc_pb::Devices, ::fc_pb::Empty>
            *server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetControllerState<
      WithStreamedUnaryMethod_SetControllerState<
          WithStreamedUnaryMethod_GetControllerConfig<
              WithStreamedUnaryMethod_SetControllerConfig<
                  WithStreamedUnaryMethod_GetDevices<
                      WithStreamedUnaryMethod_SetDevices<Service>>>>>>
      StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetControllerState<
      WithStreamedUnaryMethod_SetControllerState<
          WithStreamedUnaryMethod_GetControllerConfig<
              WithStreamedUnaryMethod_SetControllerConfig<
                  WithStreamedUnaryMethod_GetDevices<
                      WithStreamedUnaryMethod_SetDevices<Service>>>>>>
      StreamedService;
};

} // namespace fc_pb

#endif // GRPC_DevicesSpec_2eproto__INCLUDED

#ifdef __clang__
#pragma clang diagnostic pop
#elif __GNUC__
#pragma GCC diagnostic pop
#endif //__clang__
